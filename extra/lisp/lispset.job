* M948-1207 MCCARTHY, LISP, SETUP, 2, 3, 250, 0
       TAPE    SYSTMP,A4
       TAPE    SYSTAP,A1
       TAPE    SYSPIT,A2
       TAPE    SYSPOT,A3
       TAPE    SYSPPT,A3
       SIZE    10000Q,5000Q,4200Q,27000Q
       SETSET  ADD LISP DEFINITIONS.
attrib (DEF1 (expr (LAMBDA (OB l) (prog nil
      (rplaca (prop ob pro (function (lambda nil
          (cddr (rplacd ob 
		(cons pro (cons nil (cdr ob))) )))) ) l)
      (return ob) ))))
attrib (DEFlist (expr (LAMBDA (L PRO) 
      (maplist l (function (lambda (j)
               (def1 (caar j) (cadar j))))) )))
attrib (DEFine (expr (LAMBDA (J) (DEFlist J (QUOTE EXPR)))))
DEFINE ((
   (MEMBER (LAMBDA (U V) (COND ((NULL V) NIL) 
        ((EQUAL (CAR V) U) T)
     (T (MEMBER U (CDR V)))        )))
   (FLAG (LAMBDA (L FL)
          (PROG (X)
            LOOP (COND ((NULL L) (RETURN NIL)))
                 (SETQ X (CAR L))
                 (SETQ L (CDR L))
                 (COND
                    ((NOT (MEMBER FL (CDR X)))
                      (RPLACD X (CONS FL (CONS NIL (CDR X))))))
                 (GO LOOP))))          
    (REMFLAG (LAMBDA (L FL) (PROG NIL
      LOOP (COND 
              ((NULL L) (RETURN NIL)))
           (REMPROP (CAR L) FL)
           (SETQ L (CDR L))
           (GO LOOP))))
   (TRACE (LAMBDA (L) (FLAG L (QUOTE TRACE))))
   (UNTRACE (LAMBDA (L) (REMFLAG L (QUOTE TRACE))))
   (OPDEFINE1 (LAMBDA (OP VAL) (Prog (x)
        (remprop op (quote sym))
        (attrib op (cons (quote sym) (cons (cdr val) nil)))
        (return op))
   ))
   (OPDEFINEX (LAMBDA (OP VAL) (Prog (x)
        (remprop op (quote sym))
        (setq x (cdr op))
        (rplacd op (cons (quote sym) nil))
        (rplacd (cddr op) val)
        (rplacd val x)
        (return op))
   ))
   (OPDEFINE (LAMBDA (L) 
       (maplist l (function (lambda (j)
             (opdefine1 (caar j) (cadar j)))))))
   (PROG2 (LAMBDA (X Y) Y))
   (PRINTP1 (LAMBDA (L) 
        (COND ((NULL L) NIL) 
              (T (PROG2 
                   (PRINT (CAR L)) 
                 (SEARCH (QUOTE (FLOAT SUBR FSUBR PNAME APVAL FIX))
                     (FUNCTION (LAMBDA (J) (EQUAL ( CAR J) (CAR L))))
                     (FUNCTION (LAMBDA (J) (PRINTP1 (CDR (CDR L)))))
                     (FUNCTION (LAMBDA (J) (PRINTP1 (CDR L))))
                   )
                 )
                )
         )
    ))                                     
(PRINTPROP (LAMBDA (C) (PROG2 (PRINT (LIST (QUOTE PROPERTIES) (QUOTE OF)
 C)) (PRINTP1 (CDR C)))))                                               
  (CSET (LAMBDA (SYM VAL)
          (PROG (TOSTORE)
            (REMPROP SYM (QUOTE APVAL))
            (SETQ TOSTORE (LIST VAL))
            (ATTRIB SYM (LIST (QUOTE APVAL) TOSTORE))
            (RETURN TOSTORE))))
  (EFFACE (LAMBDA (X L) 
             (COND
               ((NULL L) NIL) 
               ((EQUAL X (CAR L)) (CDR L))
               (T RPLACD(L (EFFACE(X CDR L)))))))
(LENGTH(LAMBDA (M) (PROG (N) (SETQ N 0)
A (COND ((NULL M) (RETURN N)) ) (SETQ N (ADD1 N)) (SETQ M (CDR M))
(GO A) )))
(REVERSE (LAMBDA (X) (PROG (Y) A (COND ((NULL X) (RETURN Y))) (SETQ Y (CLISP0590
ONS (CAR X) Y)) (SETQ X (CDR X)) (GO A))))                              LISP0600
  (CAAAAR (LAMBDA (X) (CAR (CAR (CAR (CAR X))))))
  (CAAADR (LAMBDA (X) (CAR (CAR (CAR (CDR X))))))
  (CAADAR (LAMBDA (X) (CAR (CAR (CDR (CAR X))))))
  (CAADDR (LAMBDA (X) (CAR (CAR (CDR (CDR X))))))
  (CADAAR (LAMBDA (X) (CAR (CDR (CAR (CAR X))))))
  (CADADR (LAMBDA (X) (CAR (CDR (CAR (CDR X))))))
  (CADDAR (LAMBDA (X) (CAR (CDR (CDR (CAR X))))))
  (CADDDR (LAMBDA (X) (CAR (CDR (CDR (CDR X))))))
  (CDAAAR (LAMBDA (X) (CDR (CAR (CAR (CAR X))))))
  (CDAADR (LAMBDA (X) (CDR (CAR (CAR (CDR X))))))
  (CDADAR (LAMBDA (X) (CDR (CAR (CDR (CAR X))))))
  (CDADDR (LAMBDA (X) (CDR (CAR (CDR (CDR X))))))
  (CDDAAR (LAMBDA (X) (CDR (CDR (CAR (CAR X))))))
  (CDDADR (LAMBDA (X) (CDR (CDR (CAR (CDR X))))))
  (CDDDAR (LAMBDA (X) (CDR (CDR (CDR (CAR X))))))
  (CDDDDR (LAMBDA (X) (CDR (CDR (CDR (CDR X))))))
(PUNCHLAP (LAMBDA NIL (PROG (X L N EXP)
A    (SETQ X (READ))
     (PUNCH BLANK)
     (COND ((NULL X) (RETURN (PUNCH NIL))))
     (SETQ L (LENGTH (CADADR X)))
     (SETQ N (CAR X))
     (SETQ EXP (CADR X))
     (SETQ X (PHASE2 (PASSONE N EXP) N))
     (PUNCH (LIST (CONS (LIST N (QUOTE SUBR) L)         (CAR X))
         (CADR X)))
     (GO A)                )))
(PUNCHDEF (LAMBDA (L) (MAPCON L (FUNCTION (LAMBDA (X) ((LAMBDA (L1) (CONLISP041
D ((NULL L1) (LIST (CAR X))) (T (PROG2 (PUNCH (LIST (CAR X) (CAR L1))) NLISP042
IL)))) (PROP (CAR X) (QUOTE EXPR) (FUNCTION (LAMBDA NIL NIL)))))))))    LISP043
))

DEFLIST ((
  (CONC (LAMBDA (ARGS ALIST)
          (MAPCON ARGS 
                  (FUNCTION 
                    (LAMBDA (L) 
                      (EVAL (CAR L) ALIST))))))
  (CSETQ (LAMBDA (ARGS ALIST)
           (CSET (CAR ARGS) (EVAL (CADR ARGS) ALIST))))
  (SELECT (LAMBDA (ARGS ALIST) (PROG (V)
            (SETQ V (PRINT(EVAL (CAR ARGS) ALIST)))
       LOOP (SETQ ARGS (CDR ARGS))
            (COND ((NULL (CDR ARGS)) (RETURN (EVAL (CAR ARGS) ALIST)))
                  ((EQUAL V (EVAL (CAAR ARGS) ALIST)) 
                             (RETURN (EVAL (CADAR ARGS) ALIST))))
            (GO LOOP)
       )))
            
) FEXPR)

OPDEFINE ((
   (AXT 774Q8) (CLA 500Q8) (LDQ 560Q8) (LXA 534Q8)
   (LXD 4534Q8) (PAX 734Q8) (PDX 4734Q8) (PXA 754Q8)
   (PXD 4754Q8) (STD 622Q8) (STO 601Q8) (STQ 4600Q8)
   (STR 5000Q8) (STZ 600Q8) (SUB 402Q8) (SXA 634Q8)
   (SXD 4634Q8) (TIX 2000Q8) (TLQ 40Q8) (TNX 6000Q8)
   (TNZ 4100Q8) (TRA 20Q8) (TSX 74Q8) (TXH 3000Q8)
   (TXI 1000Q8) (TXL 7000Q8) (TZE 100Q8) (XCA 131Q8)
))

LAP (( (GREATER SUBR 2) (TLQ (* 3)) (PXA 0 0)
       (TRA 1 4) (CLA (QUOTE *T*)) (TRA 1 4) ) NIL)

GREATER (200 NIL)

GREATER (NIL 200)


STOP)))   )))   )))   )))
       TEST  WANG ALGORITHM FOR THE PROPOSITIONAL CALCULUS
DEFINE((
(THEOREM (LAMBDA (S) (TH1 NIL NIL (CADR S) (CADDR S))))
(TH1 (LAMBDA (A1 A2 A C)(COND ((NULL A)
     (TH2 A1 A2 NIL NIL C)) (T
     (OR (MEMBER (CAR A) C) (COND ((ATOM (CAR A))
     (TH1 (COND ((MEMBER (CAR A) A1) A1)
     (T (CONS (CAR A) A1))) A2 (CDR A) C))
     (T (TH1 A1 (COND ((MEMBER (CAR A) A2) A2)
     (T (CONS (CAR A) A2))) (CDR A) C))))))))

(TH2 (LAMBDA (A1 A2 C1 C2 C) (COND
     ((NULL C) (TH A1 A2 C1 C2))
     ((ATOM (CAR C)) (TH2 A1 A2 (COND
     ((MEMBER (CAR C) C1) C1) (T
     (CONS (CAR C) C1))) C2 (CDR C)))
     (T (TH2 A1 A2 C1 (COND ((MEMBER
     (CAR C) C2) C2) (T (CONS (CAR C) C2)))
     (CDR C))))))

(TH (LAMBDA (A1 A2 C1 C2) (COND ((NULL A2) (AND (NOT (NULL C2))
     (THR (CAR C2) A1 A2 C1 (CDR C2)))) (T (THL (CAR A2) A1 (CDR A2)
     C1 C2)))))

(THL (LAMBDA (U A1 A2 C1 C2) (COND
     ((EQ (CAR U) (QUOTE NOT)) (TH1R (CADR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE AND)) (TH2L (CDR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE OR)) (AND (TH1L (CADR U) A1 A2 C1 C2)
     (TH1L (CADDR U) A1 A2 C1 C2) ))
     ((EQ (CAR U) (QUOTE IMPLIES)) (AND (TH1L (CADDR U) A1 A2 C1
     C2) (TH1R (CADR U) A1 A2 C1 C2) ))
     ((EQ (CAR U) (QUOTE EQUIV)) (AND (TH2L (CDR U) A1 A2 C1 C2)
     (TH2R (CDR U) A1 A2 C1 C2) ))
     (T (ERROR (LIST (QUOTE THL) U A1 A2 C1 C2)))
     )))

(THR (LAMBDA (U A1 A2 C1 C2) (COND
     ((EQ (CAR U) (QUOTE NOT)) (TH1L (CADR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE AND)) (AND (TH1R (CADR U) A1 A2 C1 C2)
     (TH1R (CADDR U) A1 A2 C1 C2) ))
     ((EQ (CAR U) (QUOTE OR)) (TH2R (CDR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE IMPLIES)) (TH11 (CADR U) (CADDR U)
     A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE EQUIV)) (AND (TH11 (CADR U) (CADDR U)
     A1 A2 C1 C2) (TH11 (CADDR U) (CADR U) A1 A2 C1 C2) ))
     (T (ERROR (LIST (QUOTE THR) U A1 A2 C1 C2)))
     )))

(TH1L (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM V) (OR (MEMBER V C1)
     (TH (CONS V A1) A2 C1 C2) ))
     (T (OR (MEMBER V C2) (TH A1 (CONS V A2) C1 C2) ))
     )))

(TH1R (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM V) (OR (MEMBER V A1)
     (TH A1 A2 (CONS V C1) C2) ))
     (T (OR (MEMBER V A2) (TH A1 A2 C1 (CONS V C2))))
     )))


(TH2L (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM (CAR V)) (OR (MEMBER (CAR V) C1)
     (TH1L (CADR V) (CONS (CAR V) A1) A2 C1 C2)))
     (T (OR (MEMBER (CAR V) C2) (TH1L (CADR V) A1 (CONS (CAR V)
     A2) C1 C2)))
     )))

(TH2R (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM (CAR V)) (OR (MEMBER (CAR V) A1)
     (TH1R (CADR V) A1 A2 (CONS (CAR V) C1) C2)))
     (T (OR (MEMBER (CAR V) A2) (TH1R (CADR V) A1 A2 C1
     (CONS (CAR V) C2))))
     )))

(TH11 (LAMBDA (V1 V2 A1 A2 C1 C2) (COND
     ((ATOM V1) (OR (MEMBER V1 C1) (TH1R V2 (CONS V1 A1) A2 C1
     C2)))
     (T (OR (MEMBER V1 C2) (TH1R V2 A1 (CONS V1 A2) C1 C2)))
     )))
))


THEOREM
((ARROW (P) ((OR P Q))))


THEOREM
((ARROW ((OR A (NOT B))) ((IMPLIES (AND P Q) (EQUIV P Q))) ))

TRACE ((THEOREM TH1 TH2 TH THL THR TH1L TH1R THEL TH2R TH11))
UNTRACE ((THEOREM TH1 TH2 THR THL TH1L TH1R TH2L TH2R TH11))

STOP)))   )))   )))   )))
       TEST    LAP
DEFINE ((
(TRACESET (LAMBDA (L) (TRACSQ L (FUNCTION TRACSS))))                    ARYT0030
                                                                        ARYT0040
(UNTRACESET (LAMBDA (L) (TRACSQ L (FUNCTION TRACSU))))                  ARYT0050
                                                                        ARYT0060
(TRACSQ (LAMBDA (L FN) (MAPCON L (FUNCTION (LAMBDA (J) (PROG (A)        ARYT0070
(SETQ A (PROP (CAR J) (QUOTE EXPR) (FUNCTION (LAMBDA () (PROG2 (PRINT
(CONS (CAR J) (QUOTE (IS NOT EXPR DEFINED)))) NIL)))))                  ARYT0090
(COND((NULL A) (RETURN NIL)))                                           ARYT0100
(SETQ A (CADDAR A))
(COND ((NOT (EQ (CAR A) (QUOTE PROG))) (RETURN(PROG2 (PRINT (CONS(CAR J)
(QUOTE (IS NOT A PROGRAM))))     NIL) )))                               ARYT0110
(SETQ A (CDR A))                                                        ARYT0120
TEST (SETQ A (CDR A))                                                   ARYT0130
(COND ((NULL A) (RETURN (LIST (CAR J))))                                ARYT0140
     ((EQ (CAAR A) (QUOTE SETQ)) (FN A)) )
(GO TEST)  ))) )))                                                      ARYT0190
                                                                        ARYT0200
(TRACSS (LAMBDA (L) (RPLACD L (NCONC (LIST                              ARYT0210
(QUOTE (PRINT BLANK))                                                   ARYT0220
(LIST (QUOTE PRINT)(LIST (QUOTE QUOTE) (LIST (CADAR L) EQSIGN)))
(LIST (QUOTE PRINT) (CADAR L))     )  (CDR L)))))                       ARYT0240
                                                                        ARYT0250
(TRACSU (LAMBDA (L) (RPLACD L (CDDDDR L))))                             ARYT0260
                                                                        ARYT0270
))
DEFINE ((
(LENGTH(LAMBDA (M) (PROG (N) (SETQ N 0)
A (COND ((NULL M) (RETURN N)) ) (SETQ N (ADD1 N)) (SETQ M (CDR M))
(GO A) )))
(REVERSE (LAMBDA (X) (PROG (Y) A (COND ((NULL X) (RETURN Y))) (SETQ Y (CLISP0590
ONS (CAR X) Y)) (SETQ X (CDR X)) (GO A))))                              LISP0600
(MEMBER (LAMBDA (U V) (COND ((NULL V) NIL) ((EQUAL (CAR V) U) T)
     (T (MEMBER U (CDR V)))        )))
(COMVAL (LAMBDA (EXP STOMAP NAME) (PROG NIL
(COND     ((OR (ATOM EXP) (MEMBER (CAR EXP) (QUOTE (QUOTE SPECIAL))))
               (LAC EXP))
      ((EQ (CAR EXP) (QUOTE SETQ)) (PROG NIL
           (COMVAL (CADDR EXP) STOMAP NAME)
           (ATTACH (LIST (CONS (QUOTE STO) (LOCATE (CADR EXP)))))  ))
      ((EQ (CAR EXP) (QUOTE COND)) (COMCOND (CDR EXP) T))
      ((EQ (CAR EXP) (QUOTE PROG)) (COMPROG (CDDR EXP) (CADR EXP) NAME))
      ((EQ (CAR EXP) (QUOTE OR)) (COMBOOL F F (CDR EXP) NIL))
      ((EQ (CAR EXP) (QUOTE AND)) (COMBOOL T F (CDR EXP) NIL))
      ((ATOM (CAR EXP)) (CALL (CAR EXP) (COMLIS (CDR EXP))))
      (T (PROG NIL (COMPLY (CAR EXP) (CDR EXP))
           (COMVAL (CADDAR EXP) STOMAP NAME)))          )
(SETQ AC NAME)
(RETURN NAME)                             )))
(COMPLY (LAMBDA (FN ARGS)   (MAP (PAIR (CADR FN) ARGS)
     (FUNCTION (LAMBDA (J) (PROG NIL (COMVAL (CDAR J) STOMAP
          (GENSYM)) (STORE (CAAR J) T)))))   ))
(COMLIS (LAMBDA (EXP) (PROG (X) (RETURN (MAPLIST EXP (FUNCTION (LAMBDA (LISP0170
J) (COND ((OR (EQ (CAAR J) (QUOTE QUOTE)) (ATOM (CAR J))) (CAR J)) (X (PLISP0180
ROG2 (STORE AC T) (COMVAL (CAR J) STOMAP (GENSYM)))) (T (PROG2 (SETQ X TLISP0190
) (COMVAL (CAR J) STOMAP (GENSYM))))))))))))                            LISP0200
(LAC (LAMBDA (X) (COND ((EQUAL AC X) NIL) (T (ATTACH (LIST (CONS (QUOTE LISP0880
CLA) (LOCATE X))))))))                                                  LISP0890
(STORE (LAMBDA (X Y) (PROG NIL (COND ((OR (NULL X) (EQ (CAR X) (QUOTE QULISP0900
OTE))) (RETURN NIL))) (SETQ STOMAP (CONS (CONS X (LIST (LIST (ADD1 (CAADLISP0910
AR STOMAP)) (QUOTE *N)) 1)) STOMAP)) (COND (Y (ATTACH (LIST (CONS (QUOTELISP0920
 STO) (LOCATE X)))))) (SETQ LENGTH (MAX LENGTH (CAADAR STOMAP))))))     LISP0930
(PHASE2X (LAMBDA (J) (AND (EQ (CAADR EXP) (CADAR J)) (EQ (CAAR J) (QUOTE
 NULL)) (EQUAL (CADR J) (QUOTE (QUOTE NIL))))) (CADAR (CDDR EXP)))
(PHASE2Y (LAMBDA (J) (LIST (COND ((LESSP J 3) 0) (T (DIFFERENCE (TIMES J
   2) 4)))))) 
(PHASE2 (LAMBDA (EXP NAME) (PROG (AC LISTING STOMAP LENGTH) (COND ((PHAS
E2X (CADAR (CDDR EXP)))                               (PROG2 (ATTACH (QULISP1000
OTE ((TZE 1 4)))) (SETQ EXP (LIST (CAR EXP) (CADR EXP) (CONS (QUOTE CONDLISP1010
) (CDDAR (CDDR EXP)))))))) (ATTACH (LIST (LIST (QUOTE TNX) (LIST (QUOTE LISP1020
E) NAME) 1 (QUOTE *MN)) (APPEND (QUOTE (TSX *MOVE 1)) (PHASE2Y 
                                                         (LENGTH (CADR ELISP1040
XP)))))) (SETQ LENGTH 0) (SETQ STOMAP (QUOTE ((NIL (0 *N) 1)))) (MAP (CALISP1050
DR EXP) (FUNCTION (LAMBDA (J) (STORE (CAR J) F)))) (SETQ AC NIL) (COMVALLISP1060
 (CADDR EXP) STOMAP NIL) (COND ((NOT (MEMBER (CAADDR EXP) (QUOTE (COND PLISP1070
ROG)))) (ATTACH (QUOTE ((TXI *RETURN 1 *MN)))))) (SETQ EXP (REVERSE LISTLISP1080
ING)) (RETURN (LIST EXP (LIST (CONS (QUOTE *MN) (PLUS LENGTH 2)) (CONS (LISP1090
QUOTE *N) (DIFFERENCE -2 LENGTH))))))))                                 LISP1100
(COMPROG (LAMBDA (EXP PROGLIS RETN) (PROG (GOLIST HOLD NAME SETS S) (SET
Q HOLD EXP) A (COND ((NULL HOLD) (GO B)) ((ATOM (CAR HOLD)) (SETQ GOLISTLISP0430
 (CONS (CONS (CAR HOLD) (GENSYM)) GOLIST))) ((NOT SETS) (COND ((EQ (CAARLISP0440
 HOLD) (QUOTE SPECBIND)) (SETQ S (CADADR HOLD))) (T (SETQ SETS T))))) (SLISP0450
ETQ HOLD (CDR HOLD)) (GO A) B                  (SETQ HOLD PROGLIS) C (COLISP0460
ND ((NULL HOLD) (GO G))) (STORE (CAR HOLD) NIL) (COND ((NOT (EQ (CAR HOLLISP0470
D) S)) (ATTACH (LIST (CONS (QUOTE STZ) (LOCATE (CAR HOLD))))))) (SETQ HOLISP0480
LD (CDR HOLD)) (GO C) G (SETQ HOLD EXP) D (SETQ AC NIL) (SETQ NAME (GENSL9SP0490
YM)) (COND ((NULL HOLD) (GO E)) ((ATOM (CAR HOLD))                      
(ATTACH (LIST (CDR (SASSOC (CAR HOLD) GOLIST NIL)))) ) ((EQ (CAAR HOLD) LISP0510
(QUOTE GO)) (ATTACH (LIST (LIST (QUOTE TRA) (CDR (SASSOC (CADAR HOLD) GOLISP0520
LIST (FUNCTION (LAMBDA NIL (ERROR (QUOTE GO)))))))))) ((EQ (CAAR HOLD) (LISP0530
QUOTE COND)) (COMCOND (CDAR HOLD) F)) (T (COMVAL (CAR HOLD) STOMAP NAME)LISP0540
)) (SETQ HOLD (CDR HOLD)) (GO D) E (COND (RETN (ATTACH (LIST RETN)))))))L9SP0550
(COMPACT (LAMBDA (EXP NAME) (COND 
     ((EQ (CAR EXP) (QUOTE NULL)) (PROG2 (SETQ SWITCH (NOT SWITCH))
               (COMPACT (CADR EXP) NAME)))
     ((EQUAL EXP (QUOTE (QUOTE *T*   ))) (COND (SWITCH (ATTACH (LIST
          (LIST (QUOTE TRA) NAME)))) (T (SETQ FLAG F))))
     ((EQ (CAR EXP) (QUOTE OR)) (COMBOOL F T (CDR EXP) SWITCH))
     ((EQ (CAR EXP) (QUOTE AND)) (COMBOOL T T (CDR EXP) SWITCH))
     (T (PROG2
     (COND ((EQ (CAR EXP) (QUOTE EQ))
          (CEQ EXP STOMAP))
         (T (COMVAL EXP STOMAP (GENSYM))))
          (ATTACH (LIST (LIST (COND (SWITCH (QUOTE TNZ)) (T(QUOTE TZE)))
                    NAME)))        ))         )))
(COMBOOL (LAMBDA (FN MODE EXP A) (PROG (GEN SWITCH)
     (SETQ GEN (GENSYM))
A    (SETQ SWITCH NIL)
     (COND ((NULL EXP) (GO C))
         ((AND MODE (NULL (CDR EXP))      (EQ A FN) ) (GO B)))
     (COMPACT   (COND (FN (CAR EXP)) (T (LIST (QUOTE NULL) (CAR EXP))))
          (COND ((AND MODE (NOT A     )) (COND (FN NAME) (T GEN)))
                    (T (COND ((NOT MODE) GEN)  (FN GEN) (T NAME)))    ))
     (SETQ AC (COND ((EQ (CAAR LISTING) (QUOTE TNZ)) (QUOTE (QUOTE NIL))
            ) (T (QUOTE (QUOTE *T*   )))))
     (SETQ EXP (CDR EXP))
     (GO A)
B    (COMPACT  (COND (FN (LIST (QUOTE NULL) (CAR EXP)))
          (T (CAR EXP))   )         NAME)
C    (COND ((NOT MODE) (ATTACH (LIST (QUOTE (TRA (* 2))) (LIST (QUOTE
          CLA) (LIST (QUOTE QUOTE) FN))       ))))
     (ATTACH (LIST GEN))
     (COND ((NOT MODE) (ATTACH (LIST (LIST (QUOTE CLA) (LIST
          (QUOTE QUOTE) (NOT FN)))))))
      )))
(COMCOND (LAMBDA (EXP MODE)    (PROG (FLAG SWITCH GEN)
     (SETQ FLAG T)
A    (COND ((NULL EXP) (GO B)))
     (SETQ GEN (GENSYM))
     (SETQ SWITCH NIL)
     (COND((AND (NOT MODE) (EQ (CAADAR EXP) (QUOTE GO)))  (GO C)))
     (COMPACT (CAAR EXP) GEN)
     (SETQ AC (COND (SWITCH (QUOTE (QUOTE NIL))) (T NIL)))
     (COMVAL (CADAR EXP) STOMAP NAME)
     (COND ((OR (AND NAME (NULL (CDR EXP)))
          (MEMBER (CAADAR EXP) (QUOTE (RETURN GO))))
          (GO L)))
     (ATTACH (LIST (COND (NAME (LIST (QUOTE TRA) NAME))
          (T (QUOTE (TXI *RETURN 1 *MN)))           )))
L    (ATTACH (LIST GEN))
D    (SETQ EXP (CDR EXP))
     (SETQ AC (COND (SWITCH (QUOTE NIL))  (T (QUOTE (QUOTE NIL)))))
     (GO A)
B    (COND (NAME (ATTACH (LIST NAME))))
     (RETURN NIL)
C    (COMPACT (LIST (QUOTE NULL) (CAAR EXP))
          (CDR (SASSOC (CADR (CADAR EXP)) GOLIST (FUNCTION
                     (LAMBDA (V) (ERROR (QUOTE GO)))))))
     (GO D)            )))
(CEQ (LAMBDA (EXP STOMAP) (PROG (A) (SETQ A (COMLIS (CDR EXP))) (COND ((LISP1130
EQUAL(CAR A)AC)(ATTACH (LIST (CONS (QUOTE SUB) (LOCATE (CADR A)))))) (T LISP1140
(PROG2 (LAC (CADR A)) (ATTACH (LIST (CONS (QUOTE SUB) (LOCATE (CAR A))))LISP1150
)))) (SETQ SWITCH (NOT SWITCH)))))                                      LISP1160
(CALL (LAMBDA (FN ARGS)    (PROG (HOLD ITEM NUM)
     (COND ((MEMBER FN (QUOTE(SPECBIND SPECRSTR    LIST RETURN GO)))
               (GO E))
          ((NULL ARGS) (GO D))
          ((NULL (CDR ARGS)) (GO C)))
     (SETQ HOLD (REVERSE (CDDR ARGS)))
     (SETQ NUM (LENGTH ARGS))
     (COND ((GREATERP NUM 20) (ERROR (QUOTE ARGS))))
A    (COND ((NULL HOLD) (GO B)))
     (SETQ ITEM (CAR HOLD))
     (COND ((EQUAL ITEM (QUOTE (QUOTE NIL))) (ATTACH (LIST (LIST
               (QUOTE STZ) (LIST (QUOTE $ALIST) NUM)))))
           ((EQUAL ITEM AC) (ATTACH (LIST (LIST (QUOTE STO)
               (LIST (QUOTE $ALIST) NUM)))))
     (T (ATTACH (LIST (LIST (QUOTE STQ) (LIST (QUOTE $ALIST) NUM))
               (CONS (QUOTE LDQ) (LOCATE ITEM))   ))))
     (SETQ HOLD (CDR HOLD))
     (SETQ NUM (SUB1 NUM))
     (GO A)
B    (COND ((EQUAL AC (CADR ARGS)) (COND ((EQUAL AC (CAR ARGS))
     (ATTACH (QUOTE ((LDQ($ALIST 2)) (STO ($ALIST 2))))))
               (T (ATTACH (QUOTE ((XCA)))))))
          (T (ATTACH (LIST (CONS (QUOTE LDQ) (LOCATE (CADR ARGS)))))))
C    (LAC (CAR ARGS))
D    (ATTACH (LIST (LIST (QUOTE STR) (LIST (QUOTE E) FN) 7 (LENGTH
               ARGS))))
     (RETURN NIL)
E    (COND     ((EQ FN (QUOTE GO)) (ERROR (QUOTE GO)))
     ((EQ FN (QUOTE RETURN)) (PROG NIL (LAC (CAR ARGS)) (ATTACH
(LIST (COND (RETN (LIST (QUOTE TRA) RETN)) (T (QUOTE (TXI *RETURN 1
*MN))))))))
     ((EQ FN (QUOTE LIST)) (PROG (X)
          (COND ((NULL ARGS) (RETURN (ATTACH (QUOTE ((CLA (QUOTE NIL))))
               ))))
     (COND (AC (LOCATE AC)))
          (ATTACH (QUOTE ((TSX *LIST 4))))
          (ATTACH (LIST (CONS (TIMES (LENGTH ARGS) 1Q6) (LOCATE
(CAR ARGS)))))
          (SETQ X (CDR ARGS))
     A    (COND ((NULL X) (RETURN NIL)))
     (ATTACH (LIST (CONS 0 (LOCATE (CAR X)))))
          (SETQ X (CDR X))
          (GO A)                ))
     ((MEMBER FN (QUOTE (SPECBIND SPECRSTR)))    (PROG NIL
          (ATTACH (LIST (LIST (QUOTE TSX) FN 4)))
          (MAPLIST (CADAR ARGS) (FUNCTION (LAMBDA (J)
          (ATTACH (LIST (LIST (COND ((CDR J) 0)(T (QUOTE STR)))
(CAR           (LOCATE (CAR J)))1 (LIST (QUOTE SPECIAL) (CAR J))))))))))
          ))))
(ATTACH (LAMBDA (A) (COND
     ((AND (EQUAL (CAR A) (QUOTE (TXI *RETURN 1 *MN)))
          (MEMBER (CAAR LISTING) (QUOTE (TXI TRA))))     NIL)
     (T (SETQ LISTING (APPEND A LISTING)))      )))
(LOCATE (LAMBDA (X) (COND ((OR (EQ (CAR X) (QUOTE QUOTE)) (EQ (CAR X) (QLISP0940
UOTE SPECIAL)) (EQ X (QUOTE $ALIST))) (LIST X)) (T (CDR (SASSOC X STOMAPLISP0950
     (FUNCTION (LAMBDA NIL (COND ((EQ X AC) (PROG NIL
     (STORE AC T) (RETURN (SASSOC X STOMAP (FUNCTION NIL)))))
     (T (ERROR (LIST X (QUOTE UNDECLARED))))    )))    )))     )))
(DELETEL (LAMBDA (L M) (MAPCON M (FUNCTION (LAMBDA (J) (COND ((MEMBER (CLISP1200
AR J) L) NIL) (T (LIST (CAR J)))))))))                                  LISP1210
(PASSONE (LAMBDA (NAME FN) (PALAM (PROGITER NAME FN) NIL)))
(PA1 (LAMBDA (L) (MAPLIST L (FUNCTION (LAMBDA (J) (PAFORM (CAR J) B)))))LISP1520
)                                                                       LISP1530
(PA4 (LAMBDA (COMS SPECS G) (COND ((AND (NULL COMS) (NULL SPECS)) (LIST LISP1630
(QUOTE LAMBDA) (CADR FN) (PAFORM (CADDR FN) (APPEND (CADR FN) B)))) (T (LISP1640
LIST (QUOTE LAMBDA) (CADR FN) (CONC (LIST (QUOTE PROG) (LIST G)) (PA11 CLISP1650
OMS (QUOTE COMBIND)) (PA9 SPECS (QUOTE SPECBIND)) (LIST (LIST (QUOTE SETLISP1660
Q) G (PAFORM (CADDR FN) (APPEND (CADR FN) B)))) (PA9 SPECS (QUOTE SPECRSLISP1670
TR)) (PA14 COMS) (PA12 G)))))))                                         LISP1680
(PA3 (LAMBDA (L) (COND ((NULL (CDR L)) (LIST (LIST (QUOTE (QUOTE *T*   )LISP1560
) (PAFORM (CAR L) B)))) (T (CONS (LIST (LIST (QUOTE EQ) G (PAFORM (CAAR LISP1570
L ) B)) (PAFORM (CADAR L) B)) (PA3 (CDR L)))))))                        LISP1580
(PA5 (LAMBDA (VARS PROP) (COND ((NULL VARS) NIL) ((GET (CAR VARS) PROP) LISP1590
(CONS (CAR VARS) (PA5 (CDR VARS) PROP))) (T (PA5 (CDR VARS) PROP)))))   LISP1700
(PA6 (LAMBDA (KIND VAR) (LIST (LIST KIND (LIST (QUOTE QUOTE) VAR) (CONS LISP1710
(QUOTE LIST) VAR)))))                                                   LISP1720
(PA7 (LAMBDA (L B) (COND ((NULL L) (QUOTE ((RETURN (QUOTE NIL))))) ((ANDLISP1730
 (NULL (CDR L)) (EQ (CAAR L) (QUOTE GO))) L) ((ATOM (CAR L)) (CONS (CAR LISP1740
L) (PA7 (CDR L) B))) (T (CONS (PAFORM (CAR L) B) (PA7 (CDR L) B))))))   LISP1750
(PA11 (LAMBDA (VARS FUNC) (COND (VARS (PA6 FUNC VARS)) (T NIL))))       LISP1830
(PA14 (LAMDBA (COMS) (COND (COMS (LIST (LIST (QUOTE COMRSTR) (LIST (QUOTLISP1840
E QUOTE) (LENGTH COMS))))) (T NIL))))                                   LISP1850
(PA12 (LAMDBA (G) (LIST (LIST (QUOTE RETURN) G))))                      LISP1860
(COMPILE (LAMBDA (L) (MAPLIST L (FUNCTION (LAMBDA (J) (COM1 (CAR J) (GETLISP2090
 (CAR J) (QUOTE EXPR)) (GET (CAR J) (QUOTE FEXPR))))))))                LISP2100
(COM1 (LAMBDA (N A B) (PROG2 (COND (A (COM2 (QUOTE SUBR) (LENGTH (CADR ALISP2110
)) A N)) (B (COM2 (QUOTE FSUBR) (LENGTH (CADR B)) B N)) (T (PRINT (LIST LISP2120
N (QUOTE UNDEFINED))))) N)))                                            LISP2130
(COM2 (LAMBDA (TYPE LENGTH EXP NAME) (PROG (LISTING) (SETQ LISTING (PHASLISP2140
E2 (PASSONE NAME EXP) NAME)) (TERPRI) (TERPRI) (TERPRI) (PRINT (LIST NAMLISP2150
E TYPE LENGTH)) (MAP (CAR LISTING) (FUNCTION (LAMBDA (J) (PRINT (CAR J))LISP2160
))) (TERPRI)                        (LAP (CONS (LIST NAME TYPE LENGTH) (LISP2170
CAR LISTING)) (CADR LISTING)) (REMPROP NAME (QUOTE EXPR)) (REMPROP NAME LISP2180
     (QUOTE FEXPR)) (RETURN NAME))))                                    
(COMMON (LAMBDA (L) (FLAG L (QUOTE COMMON))))                           
(UNCOMMON (LAMBDA (L) (REMFLAG L (QUOTE COMMON))))
(SPECIAL (LAMBDA (X) (MAPLIST  X  (FUNCTION (LAMBDA (J)
     (DEFLIST (LIST (LIST (CAR J) (LIST NIL))) (QUOTE SPECIAL)))))))
(UNSPECIAL (LAMBDA (L) (MAP L (FUNCTION (LAMBDA (J) (REMPROP (CAR J)
(QUOTE SPECIAL)))))))
(progiter1 (LAMBDA (G1 G2 VS GS) (LIST (QUOTE LAMBDA) VS 
    (CONS (QUOTE PROG) (CONS GS (CONS G1 (PI3 (CDADDR EXP) NIL (CONS
     G2 (PAIRMAP VS GS (FUNCTION PI2) (LIST (LIST (QUOTE GO) G1))))
    )))))))
(PROGITER (LAMBDA (NAME EXP) (COND
   ((AND (EQ (CAADDR EXP) (QUOTE COND)) (PI1 (CDADDR EXP)))
(progiter1 (GENSYM) (GENSYM) (CADR EXP)
(MAPLIST (CADR EXP) (FUNCTION GENSYM))))
   (T EXP)  )))
(PI1 (LAMBDA (L) (COND
   ((NULL L) F)
   ((EQ (CAADAR L) NAME) T)
   (T (PI1 (CDR L)))  )))
(PI2 (LAMBDA (J K) (LIST (QUOTE SETQ) J K)))
(PI31 (LAMBDA (G3) (PI3 (CDR L) (NCONC C
(LIST (LIST (CAAR L) (LIST (QUOTE GO) G3))))         (CONS G3
(PAIRMAP GS (CDADAR L)
(FUNCTION PI2) (CONS (LIST (QUOTE GO) G2) S))))))
(PI3 (LAMBDA (L C S) (COND
   ((NULL L) (CONS (CONS (QUOTE COND) C) S))
   ((EQ (CAADAR L) NAME) (PI31 (GENSYM)))
   (T (PI3 (CDR L) (NCONC C (LIST (LIST (CAAR L) (LIST (QUOTE RETURN)
(CADAR L))))) S))   )))
(PALAM (LAMBDA (FN B) (COND ((ATOM FN) FN) ((EQ (CAR FN) (QUOTE LAMBDA))LISP1590
 (PA4 (PA5 (CADR FN) (QUOTE COMMON)) (PA5 (CADR FN) (QUOTE SPECIAL)) (GELISP1600
NSYM))) ((EQ (CAR FN) (QUOTE LABEL)) (COMP (CADR FN) (CADDR FN))) (T (ERLISP1610
ROR (CONS FN (QUOTE (NOT FUNCTION))))))))
(PAFORM (LAMBDA (FORM B) (COND ((ATOM FORM) (COND ((OR (NUMBERP FORM) (MLISP1220
EMBER FORM (QUOTE (NIL *T*   )))) (LIST (QUOTE QUOTE) FORM)) ((EQ FORM (LISP1230
QUOTE T)) (QUOTE (QUOTE *T*   ))) ((EQ FORM (QUOTE F)) (QUOTE (QUOTE NILLISP1240
)))
   ((GET FORM (QUOTE COMMON)) (LIST (QUOTE EVAL) (LIST (QUOTE QUOTE)
FORM) (QUOTE $ALIST)))
   ((GET FORM (QUOTE SPECIAL)) (LIST (QUOTE SPECIAL) FORM))
   ((MEMBER FORM B) FORM)
   (T (PROG NIL (PRINT (CONS FORM (QUOTE   (   UNDECLARED     ))))
(RETURN (LIST (QUOTE EVAL)(LIST (QUOTE QUOTE) FORM) (QUOTE $ALIST)))))
                                          )) ((ATOM (CAR FORM)) (COND ((LISP1270
OR (GET (CAR FORM) (QUOTE FSUBR)) (GET (CAR FORM) (QUOTE FEXPR))) (COND LISP1280
((MEMBER (CAR FORM) (QUOTE (AND OR))) (CONS (CAR FORM) (PA1 (CDR FORM)))LISP1290
) ((MEMBER (CAR FORM) (QUOTE (MAX MIN PLUS TIMES LOGOR LOGAND LOGXOR))) LISP1300
(LIST (CAR FORM) (CONS (QUOTE LIST) (PA1 (CDR FORM))) (QUOTE $ALIST))) (LISP1310
T (SELECT (CAR FORM) ((QUOTE COND) (CONS (QUOTE COND) (MAPLIST (CDR FORMLISP1320
) (FUNCTION (LAMBDA (J) (LIST (PAFORM (CAAR J) B) (PAFORM (CADAR J) B)))LISP1330
)))) ((QUOTE LIST) (CONS (QUOTE LIST) (PA1 (CDR FORM)))) ((QUOTE QUOTE) LISP1340
FORM) ((QUOTE PROG) (PA8 (PA5 (CADR FORM) (QUOTE COMMON)) (PA5 (CADR FORLISP1350
M) (QUOTE SPECIAL)) (GENSYM))) ((QUOTE FUNCTION) (LIST (QUOTE FUNC) (LISLISP1360
T (QUOTE QUOTE) (COMP (GENSYM) (CADR FORM))) (QUOTE $ALIST))) ((QUOTE SELISP1370
TQ) (COND ((GET (CADR FORM) (QUOTE COMMON)) (LIST (QUOTE SETC) (LIST (QULISP1380
OTE QUOTE) (CADR FORM)) (PAFORM (CADDR FORM) B)               )) (T (LISLISP1390
T (QUOTE SETQ) (PAFORM (CADR FORM) B) (PAFORM (CADDR FORM) B))))) ((QUOTLISP1400
E GO) FORM) ((QUOTE CSETQ) (LIST (QUOTE CSET) (LIST (QUOTE QUOTE) (CADR LISP1410
FORM)) (PAFORM (CADDR FORM) B))) ((QUOTE SELECT) ((LAMBDA (G) (LIST (LISLISP1420
T (QUOTE LAMBDA) (LIST G) (CONS (QUOTE COND) (PA3 (CDDR FORM)))) (PAFORMLISP1430
 (CADR FORM) B))) (GENSYM))) ((QUOTE CONC) (PA2 (CDR FORM))) (LIST (CAR LISP1440
FORM) (LIST (QUOTE QUOTE) (CDR FORM)) (QUOTE $ALIST)))))) ((EQ (CAR FORMLISP1450
) (QUOTE NOT)) (LIST (QUOTE NULL) (PAFORM (CADR FORM) B))) ((EQ (CAR FORLISP1460
M) (QUOTE SET)) (LIST (QUOTE SETC) (PAFORM (CADR FORM) B) (PAFORM (CADDRLISP1470
 FORM) B)               )) (T (CONS (CAR FORM) (PA1 (CDR FORM)))))) ((ORLISP1480
 (EQ (CAAR FORM) (QUOTE LAMBDA)) (EQ (CAAR FORM) (QUOTE LABEL))) (CONS (LISP1490
PALAM (CAR FORM) B) (PA1 (CDR FORM)))) (T (LIST (QUOTE APPLY) (PAFORM (CLISP1500
AR FORM) B) (CONS (QUOTE LIST) (PA1 (CDR FORM))) (QUOTE $ALIST))))))    LISP1510
(PAIRMAP (LAMBDA (L M FARG Z) (PROG (A B) 
(COND ((NULL L) (RETURN Z)))
(SETQ A (SETQ B (CONS (FARG (CAR L) (CAR M)) Z)))
A
(SETQ L (CDR L))
(SETQ M (CDR M))
(COND ((NULL L) (RETURN A)))
(SETQ B (CDR (RPLACD B (CONS (FARG (CAR L) (CAR M)) Z))))
(GO A)    )))
(PA8 (LAMBDA (COMS SPECS G) (COND ((AND (NULL COMS) (NULL SPECS)) (CONS LISP1760
(QUOTE PROG) (CONS (CADR FORM) (PA7 (CDDR FORM) (APPEND (CADR FORM) B)))LISP1770
)) (T (CONC (LIST (QUOTE PROG) (CONS G (APPEND COMS SPECS))) (PA11 COMS(LISP1780
QUOTE COMBIND)) (PA9 SPECS (QUOTE SPECBIND)) (LIST (LIST (QUOTE SETQ) G LISP1790
(CONS (QUOTE PROG) (CONS (DELETEL (APPEND COMS SPECS) (CADR FORM)) (PA7 LISP1800
(CDDR FORM) (APPEND (CADR FORM) B)))))) (PA9 SPECS (QUOTE SPECRSTR)) (PALISP1810
14 COMS) (PA12 G))))))                                                  LISP1820
(COMP (LAMBDA (N E) (COND
   ((ATOM E) E)
   (T (COM2 (QUOTE SUBR) (LENGTH (CADR E)) E N))  )))
(PA9 (LAMBDA (V K) (COND
   (V (LIST (LIST K (LIST (QUOTE QUOTE) V))))
   (T NIL))))
(PA2 (LAMBDA (L) (COND
   ((NULL L) (QUOTE (QUOTE NIL)))
   (T  (LIST (QUOTE APPEND) (PAFORM (CAR L) B) (PA2 (CDR L)))))))
))

DEFINE ((
(TEST(LAMBDA (M) (PROG (N) (SETQ N 7) (SETQ N (ADD1 N)) 
           (return (CONS N M)))))
))

COMPILE ((TEST))

TEST(2)

COMPILE (( REVERSE ))

EXCISABLE (T)

COMPILE ((
    PA5 COMP PA9 PA12 PA7
))

SPECIAL ((
   NAME GS G2 FN B FORM LEN AC STOMAP LISTING SWITCH FLAG RETN GOLIST
   RENAME HOLD EXP
))

COMPILE ((
   COM2 PROGITER PROGITER1 PI1 PI2 PI3 PI31 PALAM PA4 PAFORM PA1 PA2 PA3 PA8
   DELETEL PHASE2 PHASE2Y PHASE2X COMVAL COMPROG COMCOND COMBOOL COMPACT CEQ 
   COMPLY COMLIS STORE CALL LAC ATTACH LOCATE COMPACT COM1 PA6 PA11 PA14
   COMPILE
))

UNSPECIAL ((
   NAME GS G2 FN B FORM LEN AC STOMAP LISTING SWITCH FLAG RETN GOLIST
   RENAME HOLD EXP
))

REVERSE ((A B (C . D)))

printprop (deflist)

PRINTPROP (CAR)

PRINTPROP (SETQ)

PRINTPROP (AXT)

PRINTPROP (PROG2)

PRINTPROP (REVERSE)

LENGTH ((A B C))

MEMBER ( D (A B C D E ))

MEMBER ( G (A B C D E ))

LAP (( (GREATER SUBR 2) (TLQ (* 3)) (PXA 0 0)
       (TRA 1 4) (CLA (QUOTE *T*)) (TRA 1 4) ) NIL)

GREATER (200 NIL)

GREATER (NIL 200)


COMPILE ((MEMBER))
printprop (member)

MEMBER ( D (A B C D E ))

MEMBER ( G (A B C D E ))


DEFINE (( (IMPLIES (LAMBDA (X Y) (SELECT X (Y T) Y)))))

TRACE ((IMPLIES))

PRINTPROP (IMPLIES)

IMPLIES(T T)

IMPLIES(T F)

IMPLIES(F T)
 
IMPLIES(F F)

DEFINE ((
   (REST (LAMBDA (X) (CDR X)))
   (FIRST (LAMBDA (X) (CAR X)))
   (CONNECT (LAMBDA (X Y) (CONS X Y)))
   (ELEMENT (LAMBDA (N X) (COND
          ((EQUAL N 1) (FIRST X))
          (T (ELEMENT (SUB1 N) (REST X))))))
   (UNION (LAMBDA (X Y) (COND
         ((NULL X) Y)
         ((MEMBER (FIRST X) Y)
              (UNION (REST X) Y))
         (T CONNECT X (UNION (REST X) Y))
    )))
   (PATH (LAMBDA (A B C) (COND
         ((MEMBER B (GAMMA A)) (CONNECT B C))
         ((MEMBER B (CLOSURE (FIRST A))) (COND
              ((MEMBER (FIRST A) C) (PATH (REST A) B C ))
              (T (PATH (GAMMA (FIRST A)) B (CONNECT A C))))
         (T (PATH (REST A) B C))))))
   (CLOSURE (LAMBDA (X) (COND
         ((EQUAL (GAMMA X) X) X)
          (T (CLOSURE (UNION X (GAMMA X)))))))
   (GAMMA (LAMBDA (X) (COND
          ((NULL X) NIL)
          (T (UNION (ELEMENT (FIRST A) M) (GAMMA (REST X)))))))
))
TRACE ((COMPLY COMLIS LAC STORE PHASE2 COMPROG COMPACT COMBOOL 
 COMCOND CEQ CALL ATTACH LOCATE DELETEL PASSONE PA1 PA4 PA3 PA5 PA6
 PA7 PA11 PA14 PA12 COMPILE COM1 COM2 COMMON UNCOMMON SPECIAL UNSPECIAL
  PROGITER PI1 PI2 PI3 PALAM PAFORM PAIRMAP PA8 COMP PA9 PA2 COMVAL
  PHASE2X PROGITER1))
UNTRACE ((COMPLY COMLIS LAC STORE PHASE2 COMPROG COMPACT COMBOOL 
 COMCOND CEQ CALL ATTACH LOCATE DELETEL PASSONE PA1 PA4 PA3 PA5 PA6
 PA7 PA11 PA14 PA12 COMPILE COM1 COM2 COMMON UNCOMMON SPECIAL UNSPECIAL
  PROGITER PI1 PI2 PI3 PALAM PAFORM PAIRMAP PA8 COMP PA9 PA2 COMVAL
  PHASE2X PROGITER1))

(CSETQ M (LIST((22) () () (5 6 8) () (7) (6) () (10) (9 11) (10 12)
(13 14 15) (2 19 20) () (16 17 18) () () () () () ()
(3 4 9))))

(PATH (1) (2) NIL)


define((                                                                00010
(macro (lambda (l) (deflist l (quote macro))))                          00020
                                                                        00030
(mdef (lambda (l) (cond                                                 00040
   ((atom l) l)                                                         00050
   ((eq (car l) (quote qoute)) l)                                       00060
   ((member (car l) (quote (lambda label prog)))                        00070
(cons (car l) (cons (cadr l) (cond
      ((eq (car l) (quote prog)) (maplist (cddr l) (function (lambda (j)
(mdef (car j))))))
      (t (mdef (cddr l)))) )))
   ((get (car l) (quote macro )) (mdef ((get (car l) (quote macro))     00090
l)))                                                                    00100
   (t (maplist l (function (lambda (j) (mdef (car j))))))) )))          00110
))                                                                      00120
LAP (((LAP SUBR 2)     (SXA X 4)      (STO ($ALIST 3))        P
     (XCA)      (LDQ (QUOTE NIL))      (TSX CONS 4)
     (XCA)   (CLA ($ALIST 3))          (TSX CONS 4)
X    (AXT 0 4)    (TRA PUNCH)     ) ())

UNTRACE ((CAR CDR CAADDR AND QUOTE MAPLIST SETQ LIST LAMBDA CONS
         APPEND))


STOP)))   )))   )))   )))
       TEST    SIMPLIFY

opdefine (((tlq 40q8)))
lap (( (greater subr 2) (tlq (* 3)) (cla (quote nil)) (tra 1 4)
(cla (quote *true*)) (tra 1 4)) nil)
EXCISE (NIL) 
define ((
(infix (lambda (l s) (cond ((null l) nil) ((null (cdr l)) (list (makalg lisp0970
(car l)))) (t (cons (makalg (car l)) (cons s (infix (cdr l) s)))))))    lisp0980
(makalg (lambda (e) (cond ((or (numberp e) (atom e)) e) (t (select (car lisp1020
e) ((quote plus) (infix (cdr e) pluss)) ((quote prdct) (infix (cdr e) stlisp1030
ar)) ((quote minus) (list dash (makalg (cdr e)))) ((quote recip) (list 1lisp1040
 slash (makalg (cdr e)))) ((quote power) (infix (cdr e) starr)) ((quote lisp1050
subt) (infix (cdr e) dash)) (infix (cdr e) slash))))))                  lisp1060
(simpls (lambda (l) (prog (nums negind in divs collst outsw
com prds pwrs gcd)
(setq nums 0)
(setq in l)
test1 (cond
((null in) (go endt1))
((numberp (car in)) (setq nums (cond
      (negind (difference nums (car in)))
      (t (tosm (car in) nums)) )))
((atom (car in)) (subatm collist))
((eq (caar in) (quote minus)) (go mintr))
((eq (caar in) (quote plus)) (go plstr))
((eq (caar in) (quote divide)) (subdiv divs (plotnum (cadar in))))
((eq (caar in) (quote recip)) (prog () (rplaca in (list (quote
divide) 1 (cdar in))) (subdiv divs (cons 1 1)) ))
((eq (caar in) (quote prdct)) ((lambda (a) (subprod collst)) (plotnum
(car in))))
((eq (caar in) (quote subt)) (go substr))
(t (subatm collst)))
(setq in (cdr in))
(setq negind f)
(go test1)
subtr (setq in (append (cdr (unsubt (car in)))(cdr in)))
mintr (setq negind t)
(cond ((eq (cadar in) (quote plus)) (setq in (nconc (concmn (cddar in))
(cdr in))))    )
   (setq in (cons (cdar in) (cdr in)))
(go test1)
plstr (setq in (append (cdar in ) (cdr in)))
(go test1)
endt1 (cond 
       ((null divs) (go test2))     )
(map divs (function (lambda (j) ((lambda (d) (map d (function
(lambda (k) (search com
(function (lambda (i) (equal (caar i) (caar k))))
(function (lambda (i) (cond
   ((greaterp (cdar i) (cdar k)) nil)
   (t (rplacd (car i) (cdar k)))  )))
(function (lambda (i) (setq com (cons (car k) com))))   )))))
(deccmp (caddr (caar j)))   )   )))
(mapreconst collst)
(mapdivconst divs)
(map com (function recom))
(cond ((not (zerop nums)) (setq collst (cons nums collst))))
(return (simdiv (simpls (maplist (nconc divs collst)
(function (lambda (j) (simprd (cons (car j)
com)))))) (cons (quote prdct ) com)))
test2 (cond((zerop nums)(go collect))   )
colnum (cond 
   ((not (and (or (fixp nums) (zerop nums)) (mapand collst (function
(lambda (j) (fixp (cdr j))))))) (go asblot))  )
(setq gcd nums)
(map collst (function (lambda (j) (setq gcd (gcd gcd (cdar j))))))
(cond 
   ((zerop gcd) (return 0))
   ((or (onep gcd) (equal gcd -1)) (go asblot))  )
(map collst (function (lambda (j) (rplacd (car j)
(quotient (cdar j) gcd)))))
(setq nums (quotient nums gcd))
(setq outsw (cons gcd outsw))
asblot (map collst (function (lambda (j) ((lambda (a) (cond
   ((equal a o) nil)
   ((eq (car a) (quote minus)) (setq com (insord (cdr a) com)))
   (t (setq in (insord a in)))))     (reconst (car j))))))
(cond ((zerop nums) nil)
   ((minusp nums) (setq com (cons (minus nums) com)))
   (t (setq in (cons nums in))))
(setq com (resum2 com))
(setq in (resum2 in))
(setq in (resum1 in com))
(cond ((null outsw nil)
      ((null (cdr outsw))(setq outsw (car outsw)))
      (t (setq outsw (simprd outsw))) )
(cond ((null outsw) (return in))
      ((and (numberp in) (onep in)) (return outsw))
      ((and (numberp in) (numberp outsw)) (return totim in outsw))) )
(setq outsw (setneg outsw))
(setq in (setneg in))
(cond ((eq (car outsw) (quote prdct)) (setq outsw (cons (qoute prdct)
(insord in (cdr outsw)))))
      (t (setq outsw (cons (qoute prdct) (insord in (list outsw))))) )
(return (cons
   (negind (simmin outsw))
   (t outsw)))
collect (cond
   ((null collst) (return c))
   ((null (cdr collst)) (return (reconst (car collst)))) )
(setq divs (mapcon collst (function (lambda (i) (cond
   ((zerop (cdar i)) nil)
   (t (list (decomp (caar i)))))))))
(setq outsw (car divs))
test3 (setq divs (cdr divs))
(cond ((null divs) (go cont))   )
(setq outsw (compar (car divs) outsw))
(cond ((null outsw) (go colnum)) )
(go test3)
cont (map outsw (quote recom))
(map collst (function (lambda (j) rplaca (car j) (simprd
(list (caar j) (append (quote (recip prdct)) outsw))))))
(go colnum)  )))

(tosm (lambda (p q) (plus p q)))
(totim (lambda (p q) (times p q)))
(delete (lambda (x y) (cond
     ((null y) nil)
     ((eq x (car y)) (cdr y))
(t (cons (car y) (delete x (cdr y))   ))   )))
(larger (lambda (x y) (cond
   ((null x) f)
   ((null y) t)
((numberp x) (and (numberp y) (greaterp x y)))
((numberp y) t)
   ((atom x) (and (atom y) (greater x y)))
   ((atom y) t)
   ((equal (car x) (car y)) (larger (cdr x) (cdr y)))
   (t (larger (car x) (car y)))  )))
(insord (lambda (x l) (cond
((null l) (list x))
((larger (car l) x) (cons x l))
(t (cons (car l) (insord x (cdr l))))    )))

(ord (lambda (l r) (cond
((null l) r)
(t (ord (cdr l) (insord (car l) r)))    )))
 
(order (lambda (l) (ord l nil)))
(abs (lambda (n) (cond
    ((minusp n) (minus n))
    (t n) )))

(compar (lambda (a b) (mapcon a (function (lambda (j) (search b
(function (lambda (k) (equal (caar k) (caar j))))
(function (lambda (k) (list (cons (caar k) (cond
((lessp (cdar k) (cdar j)) (cdar k)) (t (cdar j)))))))
(quote (lambda (k) nil))  ))))))

(concmn (lambda (l) (maplist l (function (lambda (j)
(cons (quote minus) (car j)))))))
(divp (lambda (x y) (zerop (remainder x y))))
(dvtst (lambda () (cond
   (divind -1)
   (t 1)  )))

(gcd (lambda (m n) (cond
   ((zerop n) m)
   ((zerop m) n) 
   ((greaterp (abs m) (abs n)) (gcd n m))
   ((divp n m) m)
   (t (gcd (remainder n m) m)) )))

(inspwr (lambda (x l fn) (cond
   ((null l) (fn))
   ((equal (caddr x) (caddar l)) (rplaca (cdar l) (cons (quote prdct)
(insord (cadr x) (cond
      ((eq (caadar l) (quote prdct)) (cdadar l))
      (t (list (cadar l))))))))
   (t (inspwr x (cdr l) fn)) )))

(mapand (lambda (l fn) (or (null l) (and (fn (car l)) (mapand (cdr l)
fn)) )))

(mapdivconst (lambda (k) (map k (function (lambda (l) (rplaca l
(list (quote prdct) (cdar l) (cadaar l) (cons (quote recip) (caddr
(caar l)) ))))))))

(mapend (lambda (x fn)(mapcon x (function (lambda (j) (append (fn j)
nil))))))

(mapreconst (lambda (l) (map l (function (lambda (j)
(rplaca j (reconst (car j))))))))

(mpylss (lambda (s sl) (cond
   ((eq (car s) (quote subt)) (mpylss (unsubt s) sl))
   ((null sl) (cdr s))
   (t (mapcon (cdr s) (function (lambda (j) (maplist sl (function
(lambda (k) (list (quote prdct) (car j) (car k))))))))) )))

(plotnum (lambda (x) (cond
   ((and (eq (car x) (quote prdct)) (numberp (cadr x))) (cons (cond
      ((null (cdddr x)) (caddr x))
      (t (cons (quote prdct) (cddr x))) ) (cadr x)))
   (t (cons x 1))  )))

(prdatm (lambda (l fn) (cond
   ((null l) (fn))
   ((equal (caar l) (car in)) (rplacd (car l) (pluspr
(cdar l) (dvtst))))
   ((larger (car in) (caar l)) (rplaca (rplacd l (cons (car l)
(cdr l))) (cons (car in) (dvtst))))
   (t (prdatm (cdr l) fn))  )))

(prdpwr (lambda (l fn) (cond
   ((null l) (fn))
   ((equla (caar l) (cadar in)) (rplacd (car l) (pluspr
(cdar l) (sp4))))
   ((larger (cadar in) (caar l)) (rplaca (rplacd l (cons (car l) (cdr l)
)) (cons (cadar in) (sp4))))
   (t (prdpwr (cdr l) fn)) )))

(recom (lambda (j) (rplaca j (simpwr (caar j) (cdar j)))))

(reconst (lambda (x) (cond
   ((zerop (cdr x)) c)
   ((onep (cdr x)) (car x))
   ((numberp (car x)) (totim (car x) (cdr x)))
   ((minusp (cdr x)) (simmin (reconst (cons (car x)
(minus (cdr x))))))
   ((eq (caar x) (quote prdct )) (cons (quote prdct) (cons
(cdr x) (cdar x))))
   (t (list (quote prdct) (cdr x) (car x)))  )))

(resum (lambda (l p n) (cond
   ((null l) (resum1 (resum2 p) (resum2 n)))
   ((eq (caar l) (quote minus)) (resum (cdr l) p (nconc n (list
(cdar l)))))
   (t (resum (cdr l) (nconc p (list (car l))) n)) )))

(resum1 (lambda (p n) (cond
   ((and n(null n) (null p)) 0)
   ((null n) p)
   ((null p) (simmin n))
   (t (list (quote subt) p n)) )))

(resum2 (lambda (x) (cond
   ((null x) nil)
   ((null (cdr x)) (car x))
   (t (cons (quote plus) x)) )))

(setexp (lambda () (setq exps (nconc exps (list (cons (xadar in)
(sp4)))))))

(setneg (lambda (l) (cond
   ((and (numberp l) (minusp)) (prog2 (setq negind (not negind))
(minus l)))
   ((eq (car l) (quote minus)) (prog2 (setq negind (not negind)) (cdr l)
)) (t l) )))

(setsum (lambda () (setq sums (nconc sums (list
(cons (cadar in) (sp4)))))))

(simdiv (lambda (x y) (simprd (list x (simrcp y)))))

(simmin (lambda (x) (cond
((null x) (erroe (quote simmin)))
((numberp x) (minus x))
((eq (car x) (quote minus)) (cdr x))
((eq (car x) (quote subt)) (list (quote subt) (caddr x) (cadr x)))
(t (cons (quote minus) x))   )))

(simplify (lambda (l) (cond
   ((null l) (error (quote simplify)))
   ((or (atom l) (numberp l) )  l)
   ((eq    (car l) (quote minus)) (simmin (simplify (cdr l))))
   ((eq (car l) (quote plus)) (simpls (maplist (cdr l) (function (lambda
 (j) (simplify (car j)))))))
   ((eq (car l) (quote prdct)) (simprd (maplist (cdr l) (function(lambda
(j) (simplify (car j)))))))
   ((eq (car l) (quote divide)) (simdiv (simplify (cadr l))
(simplify (caddr l))))
   ((eq (car l) (quote subt)) (simsub (simplify (cadr l)) (simplify
(caddr l))))
   ((eq (car l) (quote power)) (simpwr (simplify (cadr l)) (simplify
(caddr l))))
   (t (simrcp (simplify (cdr l))))  )))

(sp3 (lambda (d i n) (cond
   ((null d) (cond
          ((null n) nil)
          ((greaterp i 1) (simpls (maplist n (function
(lambda (j) (simprd (list (car j))))))))
         (t (resum n nil nil)) ))
   ((null n) (cond
         ((null (cdr d)) (car d))
         (t (cons (quote prdct) d))   ))
   (t (simpls (maplist n (function (lambda (j) (simprd
(append d (list (car j)))))))))  )))

(pluspr (lambda (x y) (cond
   ((and (numberp x) (numberp y)) (tosm x y))
   (t (simpls (list x y))) )))

(simpwr (lambda (x y) (cond
   ((or (null x) (null y)) (error nil ))
   ((and (numberp y) (zerop y)) 1)
   ((and (numberp x) (zerop x)) 0)
   ((and (numberp y) (onep y)) x)
   ((and (numberp y) (numberp x)) (cond
      ((not (minusp x)) (exp  x y))
      ((and (minusp x) (divp y 2)) (exp  (minus x) y))
      ((and (minusp x) (divp (add1 y) 2)) (minus (exp  (minus x) y )))
      ((minusp y) (list (quote recip) (quote power) x (minus y)))
      (t (list (quote power) x y))))
   ((and (numberp y) (minusp y)) (simrcp (simpwr x (minus y))))
   ((eq (car y) (quote minus)) (simrcp (simpwr x (crd y))))
   ((or (numberp x) (atom x)) (list (quote power) x y))
   ((eq (car x) (quote recip)) (simrcp (simpwr (cdr x) y)))
   ((eq (car x) (quote divide)) (simdiv              (simpwr (cadr x)
y) (simpwr (caddr x) y)))
((and (eq (car x) (quote minus)) (numberp y (fixp y)) (cond
       ((divp y 2) (simpwr (cdr x) y))
       ((divp (add1 y) 2) (simmin (simpwr (cdr x) y)))
       (t (list (quote power) x y))  ))
   ((eq (car x) (quote power)) (simpwr (cadr x) (simprd (list (caadr
x) y))))
   ((eq (car x)(quote prdct)) (simprd(maplist(cdr x)(function(lambda
(j) (simpw (car j) y)))))))
   (t (list (quote power) x y)) )))

(simrcp (lambda (x) (cond ((numberp x) (quotient   1.0 x))
   ((atom x) (cons (qoute recip) x))
   ((eq (car x) (quote minus)) (simmin (simrcp (cdr x))))
   ((eq (car x) (quote recip)) (cdr x))
   ((eq (car x) (quote divide)) (cond
      ((numberp (cadr x)) (reconst (cons (caddr x) (quotient 1.0 (cadr
x)))))
      (t ((lambda (a) (list (quote divide) (reconst (cons (caddr x)
(quotient 1.0 (cdr a)))) (car a)))  (plotnum (cadr x)) )) ))
   ((eq (car x)(quote prdct))
     (simprd (maplist (cdr x) (function (lambda (j) (simrcp (car j))))))
)
   (t (cons (quote  recip) x)) )))

(simsub (lambda (x y) (simpls (list x (simmin y)))))

(sp1 (lambda (n) (cond
   ((zerop n) nil)
   (t (prog ()
          (setq denind (add1 denind)) 
          (setq densum (mpylss (caar j) densum))
          (sp1 (add1 n)) )) )))

(sp2 (lambda (n) (cond
    ((zerop) nil)
    (t (prog ()
           (setq numind (add1 numind))
           (setq numsum (mpylss (caar j) numsum))
           (sp2 (sub1 n))  ))  )))

(sp4 (lambda () (cond
   (divind (simmin (caddar in)))
   (t (caddar in)) )))

(subatm (lamdba (l) (cond
((null l) (setq collst (cons (cons (car in) (cond (negind -1)
(t 1))) colist)))
((equal(caar l)(car in))(rplacd(car l)(cond (negind (sub1 (cdar l)))
        (t (add1 (cdar l))))))
(t (subatm (cdr l)))  )))

(subdiv (lambda (l a) (cond
   ((null l) (setq divs (cons (cons (cons (quote divide) (cons (car a)
(cddar in))) (cond
      (negind (minus (cdr a)))
      (t (cdr a)))) divs)))
   ((equal (cadr (cdaar l)) (caddar in)) ((lambda (x) (cond
      ((zerop (cdr x)) (rplacd (rplaca l (cadr l)) (cddr l)))
      (t (rplaca l (cons (list (quote divide) (car x) (caddar in))
(cdr x)))) ))
(plotnum (simpls (list (reconst (cons (caddar l) (cdar l))) (reconst
(cond (negind (cons (car x) (minus (cdr a))))      (t a))))))))
   (t (subdiv (cdr l) a))   )))

(subprd (lambda (l) (cond
   ((null l) (setq collst (cons (cond
      (negind (cons (car a) (minus (cdr a))))
      (t a)) collst)))
   ((equal (caar l) (car a)) (rplacd (car l) (tosm (cond
      (negind (minus (cdr a)))
      (t (cdr a)))  (cdar l))))
   (t (subprd (cdr l)))  )))

(unsubt (lambda (a) (cons (quote plus) (nconc (cond
      ((eq (caaddr a) (quote plus)) (concmd (cdaddr a)))
      (t (list (cons (quote minus) (caddr a)))))
(cond  ((eq (caadr a) (quote plus)) (cdadr a))
      (t (list (cadr a))) ) ))))

(simprd (lambda (l) (prog (in exps denom rcppwr nums top sums divind
sign numsum densum numind denind)
 (setq numind 0)
 (setq denind 0)
 (setq nums1)
 (setq in l)
 test1 (cond
    ((null in) (go endt1))
    ((numberp (car in)) (setq nums (cond
             (divind (quotient nums (car in)))
             (t (totim nums (car n))) )))
    ((atom (car in)) (prdatm exps (function (lambda () (setq exps
 (nconc exps (list (cons (car in) (dvtst)))))))))
    ((eq (caar in) (quote minus)) (go mintr))
    ((eq (caar in) (quote prdct)) (go prdtr))
    ((eq (caar in) (quote recip)) (go rcptr))
    ((eq (caar in) (quote power)) (go pwrtr))
    ((eq (caar in) (qoute divide)) (go divtr))
    (t (prdatm sums (function (lambda () (setq sums (nconc sums
 (list (cons (car in) (dvtst))))))))))
reset (setq in (cdr in))
(setq dviind f)
(go test1)
endt1 (map exps (function (lambda (j) ((lambda (x) (cond
     ((numberp x) nil)
     ((eq (car x) (quote power)) (inspwr x in (function (lambda nil
(setq in (cons x in))))))
     ((eq (car x ) (quote recip)) (cond
     ((eq (cadr x) (quote power)) (inspwr (cdr x)
rcppwr (function (lambda () (setq rcppwr (cons (cdr x) rcppwr))))))
      (t (setq denom (cons (cdr x) denom)))))
   (t (setq top (cons x top)))))
   (simpwr (caar j) (cdar j))) )))
(map sums (function (lamdba (j) (cond
     ((minusp (cdar j)) (sp1 (cdar j)))
     (t (sp2 (cdar j))) ))))
(map in (function (lambda (j) (setq top (insord (car j) top)))))
(map rpcppwr (function (lambda (j) (setq denom (insord (car j) denom)))))
(cond ((minusp numss) (prog2 (setq sign (not sign)) (setq numns
(minus nums)))))
(cond ((zerop nums) (return 0))
      ((onep nums) nil)
      (t (setq top (cons nums top))) )
(setq denom (sp3 denom denind densum))
(setq top (sp3 top numind numsum))
(cond ((and (null top) (null denom)) (setq top 1))
      ((null top)(setq top (cons (quote recip) denom)))
      ((null denom) nil)
      (t (setq top (list (quote divide) top denom))))
(cond (sign (setq top (simmin top))) )
(cond ((or (greaterp denind 1) (greaterp numind 1)) (return (simprd
(list top)))) )
(return top)
mintr (setq in (cons (cdar in) (cdr in)))
(setq sign (not sign))
(go test1)
prdtr (setq in (append (cdar in) (cdr in)))
(go test1)
divtr (setq in (cons (cons (quote recip) (caddar in)) (cons (cadar
in) (cdr in))))
rcptr (cond
      ((eq (cadar in) (quote prdct)) (setq in (nconc (maplist (cddar
in) (quote (lambda (j) (cons (quote recip) (car j))))) (cdr in)))) )
(setq in (cons (cdar in) (cdr in)))
(setq divind t)
(go test1)
pwrtr (cond
      ((eq (caadar in) (quote prdct)) ((lambda (x) (map (dadar in)
(function (lambda (j) (prog2 (setq in (cons (list (quote power) (car j)
x) (cdr in))) (prdpwr exps (function  setexp)))))))    (caddar in)))
      ((and (numberp (caddar in)) (fixp (caddar in)) (eq (caadar in)
(qoute plus))) (prdpwr sums(function setsum)))
      (t (prdpwer exps (function setexp))) )
(go reset)
)))
(exp (lambda (x y) (cond
      ((minusp y) (recip (expt x (difference 0.0 y))))
      (t (expt x (difference y 0.0))) )))

(decomp (lambda (e) (cond
   ((eq (car e) (quote prdct)) (mapcon (cdr e) (function (lambda (j)
(decomp (car j))))))
   ((eq (car e) (quote power)) ((lambda (n) (cond
          ((and (numberp n) (fixp n)) (maplist (decomp (cadr e))
(function (lambda (j) (rplacd (car j) n)))))
          ((eq (caadr e) (quote prdct)) (maplist (cdadr e)
(function (lambda (j) (cons (list (quote power) (car j) n) 1)))))
          (t (list (cons e 1))) ))  (caddr e)))
   (t (list (cons e 1)))  )))

(diff (lambda (e x) (cond
   ((or (null e) (not (atom x))) (error (quote diff)))
   ((atom e) (cond
      ((eq x e) 1)
      (t 0) ))
   (t (select (car e)
      ((quote minus) (simmin (diff (cdr e) x)))
      ((quote recip) (simmin (simdiv (diff (cdr e) x) (simpwr (cdr e)
2))))
      ((quote plus) (simpls (maplist (cdr e) (function (lambda (j)
(diff (car j) x))))))
      ((quote prdct) (simpls (maplist (cdr e) (function (lambda (j)
(simprd (cons (diff (car j) x) (delete (car j) (cdr e)))))))))
      ((quote divide) (simdiv (simsub (simprd (list (caddr e) (diff
(cadr e) x))) (simprd (list (cadr e) (diff (caddr e) x)))) (simpwr
(caddr e) 2)))
      ((quote power) (simprd (list (caddr e) (simpwr (cadr e) (simsub
(caddr e) 1)) (diff (cadr e) x))))
      ((quote subt) (simsub (diff (cadr e) x) (diff (caddr e) x)))
      (error (quote diff))  ))  )))
   ))

STOP)))   )))   )))   )))
       TEST    LOAD METEOR SYSTEM
DEFINE ((
(METEOR
   (LAMBDA (RULES WORKSPACE) (METRIX RULES WORKSPACE NIL NIL
 NIL)))

(METRIX
   (LAMBDA (RULES WORKSPACE SHELF DISPCH TRACK) (METRIX2 RULES
 WORKSPACE)))

(METRIX2 
   (LAMBDA (RULES WORKSPACE) (PROG (PC GT A)
             (SETQ PC RULES)
       START (COND
                ((NULL PC) (RETURN (PROG2 (PRINT (QUOTE (OVER
 END OF PROGRAM))) WORKSPACE))))
             (SETQ GT (DISPATCH (COMITRULE (CAR PC))))
             (COND
                ((EQ GT (QUOTE *)) (GO NEXT))
                ((EQ GT (QUOTE END)) (RETURN WORKSPACE))
                ((EQUAL GT (CAAR PC)) (GO START)))
             (SETQ A (TRANSFER GT RULES))
             (COND 
                ((EQ (CAR A) (QUOTE NONAME)) (RETURN (PROG2
(PRINT (LIST (CADR A) (QUOTE (UNDEFINDED GO-TO IN)) (CAR PC)
)) WORKSPACE))))
             (SETQ PC A)
             (GO START)
       NEXT  (SETQ PC (CDR PC))
             (GO START))))

(COMITRULE
   (LAMBDA (RULE) (PROG (A B C D E F G M LEFT)
            (SETQ G RULE)
      TOP   (SETQ RULE (CDR RULE))
            (SETQ A (CAR RULE))
            (SETQ E (QUOTE *))
            (COND
               ((NOT (ATOM A)) (GO START))
               ((EQ A (QUOTE *)) (GO STAR))
               ((EQ A (QUOTE *M)) (GO *M))
               ((EQ A (QUOTE *T)) (GO *T))
               ((EQ A (QUOTE *U)) (GO *U)))
            (DEFLIST (CDR RULE) A)
            (RETURN (QUOTE *))
      STAR  (SETQ RULE (CDR RULE))
            (SETQ E (FSTATM RULE))
      START (COND 
               ((AND
                  (NULL TRACK)
                  (NULL M)) (GO TRACK)))
            (PRINT (QUOTE WORKSPACE))
            (PRINT WORKSPACE)
            (PRINT (QUOTE RULE))
            (PRINT G)
      TRACK (SETQ LEFT (COMITMATCH (CAR RULE) WORKSPACE))
            (COND 
               ((NULL LEFT) (RETURN E)))
      LOOP  (SETQ RULE (CDR RULE))
            (SETQ A (CAR RULE))
            (COND
               ((NULL RULE) (RETURN E))
               ((EQ A (QUOTE $)) (GO DOLL))
               ((EQUAL A 0) (GO ON))
               ((ATOM A) (GO SW))
               ((EQ (CAR A) (QUOTE /)) (GO SHELVE)))
      ON    (SETQ WORKSPACE (COMITR LEFT A))
            (COND 
               (M (PROG2 (PRINT (QUOTE WORKSPACE)) (PRINT WORKSPACE
))))
            (GO LOOP)
      DOLL  (SETQ A (CAR WORKSPACE))
      SW    (COND
               ((EQ E (QUOTE *)) (RETURN A)))
            (RETURN (QUOTE *))
      SHELVE (SHELVE LEFT A)
            (GO LOOP)
      *M    (SETQ M A)
            (GO TOP)
      *T    (SETQ TRACK A)
            (GO TOP)
      *U    (SETQ TRACK NIL)
            (GO TOP))))

(TRANSFER 
   (LAMBDA (GT RL) (PROG NIL
      START (COND
              ((NULL RL) (RETURN (LIST (QUOTE NONAME) GT))
)
               ((EQ GT (CAAR RL)) (RETURN RL)))
            (SETQ RL (CDR RL))
            (GO START))))

(DISPATCH
  (LAMBDA (GT) (PROG (A)
           (COND
              ((EQ GT (QUOTE *)) (RETURN GT)))
           (SETQ A (GTPAIR GT DISPCH))
           (COND 
              ((NULL A) (RETURN GT)))
           (RETURN (CAR A)))))

(GTPAIR
   (LAMBDA (NAME X) (PROG (A)
      START (COND
               ((NULL X) (RETURN NIL))
               ((EQUAL (CAR X) NAME) (RETURN (CDR X))))
            (SETQ X (CDDR X))
            (GO START))))

(FSTATM
   (LAMBDA (RULE) (PROG (A)
      START (SETQ A (CAR RULE))
            (COND
               ((NULL RULE) (RETURN (QUOTE *)))
               ((EQUAL A 0) (GO ON))
               ((ATOM A) (RETURN A)))
      ON    (SETQ RULE (CDR RULE))
            (GO START))))

(SHELVE
   (LAMBDA (PAIRS INST) (PROG (A B C D)
      START (SETQ INST (CDR INST))
            (COND
               ((NULL INST) (RETURN SHELF)))
            (SETQ A (CAR INST))
            (SETQ B (CAR A))
            (SETQ C (CADR A))
            (SETQ D (CDDR A))
            (COND
               ((EQ B (QUOTE *P)) (GO PR))
               ((EQ B (QUOTE *D)) (RETURN (SETDIS C (CAR D)
)))
               ((NOT (EQ C (QUOTE *))) (GO GETD)))
            (SETQ C (INDIRECT (CAR D) PAIRS))
            (SETQ D (CDR D))
      GETD  (SETQ D (COMITRIN PAIRS D))
            (SETQ A (GTSHLF C))
            (COND
               ((EQ B (QUOTE *S)) (GO ST1))
               ((EQ B (QUOTE *Q)) (GO QU1))
               ((EQ B (QUOTE *X)) (GO EX)))
            (PRINT (LIST (QUOTE (SHELVING ERROR IN)) (CAR INST
)))
            (GO START)
      PR    (COND
               ((EQ C (QUOTE /)) (RETURN (PRINT SHELF))))
      PR1   (PRINT (LIST (QUOTE SHELF) C (QUOTE CONTAINS) (
CAR (GTSHLF C))))
            (COND 
               ((NULL D) (GO START)))
            (SETQ C (CAR D))
            (SETQ D (CDR D))
            (GO PR1)
      EX    (SETQ B (CAR A))
            (RPLACA A WORKSPACE)
            (SETQ WORKSPACE B)
            (GO START)
      QU1   (RPLACA A (NCONC (CAR A) D))
            (GO START)
      ST1   (RPLACA A (APPEND D (CAR A)))
            (GO START))))

(SETDIS
   (LAMBDA (X Y) (PROG (A)
            (SETQ A (GTPAIR X DISPCH))
            (COND
               ((NULL A) (SETQ DISPCH (CONS X (CONS Y DISPCH
))))
               (T (RPLACA A Y)))
            (RETURN DISPCH))))

(GETDCT
   (LAMBDA (X Y) (PROG (A)
           (COND
             ((NOT (ATOM X)) (RETURN (LIST X))))
           (SETQ A (GET X Y))
           (COND
             ((NULL A) (RETURN X)))
           (RETURN A))))

(INDIRECT
   (LAMBDA (X PAIRS) (GTNAME X PAIRS)))
))

DEFINE ((
(COMITR
   (LAMBDA (LEFT ORDER) (PROG (A B C)
            (SETQ A (GTNAME 0 LEFT))
            (COND 
               ((EQUAL A 0) (SETQ A NIL))
               ((NULL A) (GO ON))
               ((ATOM A) (SETQ A (LIST A))))
     ON     (SETQ B (GTNAME (QUOTE WSEND) LEFT))
            (COND
               ((EQUAL ORDER 0) (SETQ C NIL))
               (T (SETQ C (COMITRIN LEFT ORDER))))
            (RETURN (APPEND A (APPEND C B))))))

(COMITRIN
   (LAMBDA (LEFT ORDER) (PROG (A B)
      START (COND
               ((NULL ORDER) (RETURN A)))
            (SETQ B (GTNAME (CAR ORDER) LEFT))
            (COND 
               ((NULL B) (GO ON))
               ((ATOM B) (SETQ B (LIST B))))
            (SETQ A (NCONC A B))
      ON    (SETQ ORDER (CDR ORDER))
            (GO START))))

(GTNAME
   (LAMBDA (NAME PRS) (PROG (A B C)
            (SETQ C (CAR NAME))
            (COND
               ((ATOM NAME) (GO START))
               ((EQ C (QUOTE FN)) (RETURN (COPYTP (APPLY (CADR
NAME) (COMITRIN PRS (CDDR NAME)) NIL))))
               ((EQ C (QUOTE *K)) (RETURN (LIST (COMITRIN PRS
(CDR NAME)))))
               ((EQ C (QUOTE *C)) (RETURN (COMPRESS (COMITRIN 
PRS (CDR NAME)))))
               ((EQ C (QUOTE *)) (RETURN (COPYTP (EVAL (CADR
NAME) NIL))))
               ((EQ C (QUOTE *W)) (RETURN (WRITES (COMITRIN
PRS (CDR NAME)))))
               ((EQ C (QUOTE *E)) (RETURN (EXPAND (GTNAME (
CADR NAME) PRS))))
               ((EQ C (QUOTE */)) (RETURN (LIST (SBMERGE (CDR
NAME)))))
               ((EQ C (QUOTE *N)) (RETURN (NEXT (CDR NAME))
))
               ((EQ C (QUOTE *R)) (RETURN (MTREAD)))
               ((EQ (CADR NAME) (QUOTE /)) (RETURN (LIST (SBMERGE
(LIST (QUOTE MERGE) C (CONS (QUOTE G99999) (CDR NAME)))))))
               ((EQ C (QUOTE *F)) (RETURN (CAAR (GTNAME (CADR
NAME) PRS))))
               ((EQ C (QUOTE *A)) (RETURN (ALL (CDR NAME))))
               ((EQ C (QUOTE QUOTE)) (RETURN (CADR NAME))))
      START (COND
               ((NULL PRS) (RETURN NAME)))
            (SETQ A (CAR PRS))
            (COND
               ((EQUAL NAME (CAR A)) (RETURN (COPYTP (CDR A 
)))))
            (SETQ PRS (CDR PRS))
            (GO START))))

(COPYTP 
   (LAMBDA (X) (COND
            ((ATOM X) X)
            (T (APPEND X NIL)))))

(EXPAND
   (LAMBDA (X) (COND
            ((ATOM X) (MAPCON (GET (CDR X) (QUOTE PNAME)) (FUNCTION
(LAMBDA (Y) (UNPACK (CAR Y))))))
            (T (CAR X)))))

(COMPRESS 
   (LAMBDA (X) (PROG NIL
            (CLEARBUFF)
            (MAP X (FUNCTION (LAMBDA (X) (PACK (CAR X)))))
            (RETURN (INTERN (MKNAM))))))

(MTREAD 
   (LAMBDA NIL (PROG (A B C)
            (SETQ A (STARTREAD))
            (GO A)
      START (SETQ A (ADVANCE))
      A     (COND
               ((EQ A (QUOTE $EOF$)) (RETURN A))
               ((EQ A (QUOTE $EOR$)) (RETURN B))
               ((EQ A (QUOTE  )) (SETQ C (NCONC C (LIST A))
))
               (T (GO B)))
            (GO START)
      B     (SETQ B (NCONC B (NCONC C (LIST A))))
            (SETQ C NIL)
            (GO START))))

(ALL
   (LAMBDA (X) (PROG (A B)
            (COND 
               ((EQ (CAR X) (QUOTE *)) (SETQ X (INDIRECT (CADR
X) PRS)))
               (T (SETQ X (CAR X))))
            (SETQ A (GTSHLF X))
            (SETQ B (CAR A))
            (RPLACA A NIL)
            (RETURN B))))

(NEXT
   (LAMBDA (X) (PROG (A B C)
            (COND 
               ((EQ (CAR X) (QUOTE *)) (SETQ X (INDIRECT (CADR 
X) PRS)))
               (T (SETQ X (CAR X))))
            (SETQ A (GTSHLF X))
            (SETQ C (CAR A))
            (COND
               ((NULL C) (RETURN NIL)))
            (SETQ B (CAR C))
            (RPLACA A (CDR C))
            (RETURN (LIST B)))))

(GTSHLF
   (LAMBDA (X) (PROG (A)
            (SETQ A (GTPAIR X SHELF))
            (COND
               ((NULL A) (GO A)))
            (RETURN A)
      A     (SETQ A (CONS NIL SHELF))
            (SETQ SHELF (CONS X A))
            (RETURN A))))

(SBMERGE
   (LAMBDA (X) (PROG (A B C D E G)
            (SETQ A (CAR X))
            (SETQ B (CADR X))
            (COND
               ((EQ (CADR B) (QUOTE /)) (GO BX)))
            (SETQ B (GTNAME B PRS))
            (COND 
               ((NOT (ATOM B)) (SETQ B (CAR B))))
      BX    (SETQ C (CADDR X))
            (COND
               ((EQ (CADR C) (QUOTE /)) (GO CX)))
            (SETQ C (GTNAME C PRS))
            (COND 
               ((NOT (ATOM X)) (SETQ C (CAR C))))
      CX    (COND
               ((OR
                  (ATOM C)
                  (NOT (EQ (CADR C) (QUOTE /)))) (SETQ C NIL
))
               (T (SETQ C (CDDR C))))
            (COND
               ((OR
                  (ATOM B)
                  (NOT (EQ (CADR B) (QUOTE /)))) (GO B)))
            (SETQ D (LIST (CAR B) (QUOTE /)))
            (SETQ B (CDDR B))
            (GO D)
      B     (SETQ D (LIST B (QUOTE /)))
            (SETQ B NIL)
      D     (COND
               ((EQ A (QUOTE AND)) (GO AND))
               ((EQ A (QUOTE MERGE)) (GO AND))
               ((EQ A (QUOTE OR)) (GO OR))
               ((EQ A (QUOTE SUBST)) (GO SUBST)))
      ERROR (PRINT (QUOTE (SUBSCRIPT ERROR)))
            (PRINT X)
            (RETURN (GTNAME (CADR X) PRS))
      AND   (COND
               ((NULL B) (GO RETURN))
               ((MEMBER (CAR B) C) (SETQ G (CONS (CAR B) G)
)))
            (SETQ B (CDR B))
            (GO AND)
      OR    (SETQ G C)
      OR1   (COND
               ((NULL B) (GO RETURN))
               ((NOT (MEMBER (CAR B) G)) (SETQ G (CONS (CAR
B) G))))
            (SETQ B (CDR B))
            (GO OR1)
      SUBST (SETQ G C)
      RETURN (COND
               ((AND 
                  (EQ A (QUOTE MERGE))
                  (NULL G)) (SETQ G C)))
            (COND
                ((NULL G) (RETURN (CAR D))))
            (RETURN (NCONC D G)))))
))

DEFINE ((
(COMITMATCH
    (LAMBDA (RULE WORKSPACE) (PROG (A B)
            (SETQ A (CMATCH (NAMER RULE) WORKSPACE NIL))
            (COND
               ((NULL A) (RETURN NIL))
               ((EQ A (QUOTE $IMP)) (RETURN NIL)))
            (SETQ B (CONS (QUOTE WSEND) (CDR A)))
            (RETURN (ADDLAST (CAR A) B)))))

(CMATCH
   (LAMBDA (RULE WORKSPACE MPAIRS) (PROG (RNAME A B C D E G
H)
            (SETQ RNAME (CAR RULE))
            (SETQ RULE (CDR RULE))
            (SETQ B (CAR RULE))
            (COND
               ((NULL RULE) (RETURN (CONS MPAIRS WORKSPACE)
))
               ((EQ B (QUOTE $0)) (GO $0))
               ((EQ B (QUOTE $)) (GO PDOLL)))
            (SETQ H (CAR B))
            (COND
               ((EQ H (QUOTE *P)) (GO PRINT))
               ((EQ H (QUOTE FN)) (GO FN))
               ((NULL WORKSPACE) (RETURN (QUOTE $IMP))))
            (SETQ G 0)
            (COND
               ((EQ B (QUOTE $1)) (SETQ G 1))
               ((EQ B (QUOTE $2)) (SETQ G 2))
               ((EQ B (QUOTE $3)) (SETQ G 3)))
            (COND
               ((NOT (EQUAL G 0)) (GO NDOLL2)))
            (GO TEST)
      $0    (COND
               ((AND
                  (NOT (NULL WORKSPACE))
                  (NULL (CDR RULE))) (SETQ B NIL))
               (T (SETQ B (CONS NIL WORKSPACE))))
             (GO WATB)
      TEST   (COND
                ((EQ H (QUOTE $)) (GO NDOLL))
                ((EQ H (QUOTE *)) (GO EVAL))
                ((EQ H (QUOTE QUOTE)) (GO ATB1))
                (T (GO ATB)))
      FN     (SETQ B (CDR B))
             (SETQ E (CONS WORKSPACE (COMITRIN MPAIRS (CDR B
))))
             (SETQ B (COPYTP (APPLY (CAR B) E NIL)))
      WATB   (COND
                ((NULL B) (RETURN NIL))
                ((EQ B (QUOTE $IMP)) (RETURN B))
                (T (RETURN (CMATCH (CONS (CDR RNAME) (CDR RULE
)) (CDR B) (ADDLAST MPAIRS (CONS (CAR RNAME) (CAR B)))))))
      PDOLL  (SETQ D (CDR RNAME))
             (SETQ RULE (CDR RULE))
             (COND
                 ((NULL RULE) (RETURN (LIST (ADDLAST MPAIRS (
CONS (CAR RNAME) WORKSPACE))))))
      DLOOP  (SETQ B (CMATCH (CONS D RULE) WORKSPACE MPAIRS)
)
             (COND
                 ((NULL WORKSPACE) (RETURN NIL))
                 ((EQ B (QUOTE $IMP)) (RETURN B))
                 (B (RETURN (CONS (ADDLAST (CAR B) (CONS (CAR
RNAME) C)) (CDR B)))))
             (SETQ C (ADDLAST C (CAR WORKSPACE)))
             (SETQ WORKSPACE (CDR WORKSPACE))
             (GO DLOOP)
      SUBMCH (SETQ B (SUBMCH B WORKSPACE))
             (GO WATB)
      PRINT  (PRINT (CDR B))
             (PRINT WORKSPACE)
      $IMP   (RETURN (QUOTE $IMP))
      EVAL   (SETQ B (EVAL (CADR B) NIL))
             (GO ATB2)
      ATB1   (SETQ B (CADR B))
             (GO ATB2)
      ATB    (COND 
                 ((ATOM B) (SETQ B (GTNAME B MPAIRS))))
      ATB2   (SETQ H (CAR WORKSPACE))
             (COND
                 ((ATOM B) (GO B))
                 ((EQ (CADR B) (QUOTE /)) (GO SUBMCH))
                 ((EQUAL B H) (SETQ B (CONS (LIST B) (CDR WORKSPACE
))))
                 (T (SETQ B NIL)))
             (GO WATB)
      B      (COND
                ((EQUAL B H) (SETQ B WORKSPACE))
                ((AND
                  (EQUAL B (CAR H))
                (EQ (CADR H) (QUOTE /))) (SETQ B (CONS (LIST
H) (CDR WORKSPACE))))
                (T (SETQ B NIL)))
             (GO WATB)
      NDOLL  (SETQ G (CDR B))
      NDOLL2 (SETQ B (DOLNM G WORKSPACE))
             (GO WATB))))

(NAMER
   (LAMBDA (X) (PROG (A B C D E)
            (SETQ A (CAR X))
            (SETQ D 1)
            (SETQ B X)
            (COND
               ((OR
                  (EQ A (QUOTE $))
                  (EQ A (QUOTE $0))) (GO START)))
            (SETQ B (CONS (QUOTE $) X))
            (SETQ E (LIST 0))
      START (COND
               ((NULL X) (RETURN (CONS E B))))
            (SETQ E (ADDLAST E D))
            (SETQ X (CDR X))
            (SETQ D (ADD1 D))
            (GO START))))

(SUBMCH
   (LAMBDA (X Y) (PROG (A B C)
            (SETQ A (CAR X))
            (SETQ B (CAR Y))
            (COND
               ((NOT (OR
                  (EQ A (QUOTE $1))
                  (EQUAL A (CAR B))
                  (EQUAL A (QUOTE ($ . 1))))) (RETURN NIL))
)
            (COND
               ((EQ (CADR B) (QUOTE /)) (GO ON))
               (T (RETURN NIL)))
      ON    (SETQ A (CDR X))
            (COND
               ((EQ (CAR A) (QUOTE /)) (GO A)))
            (PRINT (LIST (QUOTE (SUBSCRIPT ERROR SUBMCH)) X
))
            (RETURN NIL)
      A     (SETQ A (CDR A))
            (SETQ C (CDDR B))
      START (COND
                  ((NULL A) (RETURN (CONS (LIST B) (CDR Y))))
                  ((MEMBER (CAR A) C) (SETQ A (CDR A)))
                  (T (RETURN NIL)))
            (GO START))))

(DOLNM
   (LAMBDA (NUM WSPACE) (PROG (A B)
            (SETQ B (CAR WSPACE))
            (COND
               ((NUMBERP NUM) (GO NUM))
               ((EQ NUM (QUOTE NUMBER)) (GO NUMBER))
               ((EQ NUM (QUOTE ATOM)) (GO ATOM))
               ((EQ NUM (QUOTE LIST)) (GO LIST)))
            (COND
               ((OR
                  (EQUAL NUM B)
                  (EQUAL NUM (CAR B))) (GO RNIL)))
      $1    (COND
               ((ATOM B) (GO B)))
      LST   (RETURN (CONS (LIST B) (CDR WSPACE)))
      NUMBER (COND
               ((NOT (NUMBERP B)) (GO RNIL)))
      B     (RETURN WSPACE)
      ATOM  (COND
               ((ATOM B) (GO B)))
      RNIL  (RETURN NIL)
      LIST  (COND 
               ((ATOM B) (GO RNIL))
               (T (GO LST)))
      NUM   (COND
               ((EQUAL NUM 1) (GO $1)))
      START (COND
               ((EQUAL NUM 0) (RETURN (CONS A WSPACE)))
               ((NULL WSPACE) (RETURN (QUOTE $IMP))))
            (SETQ A (ADDLAST A (CAR WSPACE)))
            (SETQ WSPACE (CDR WSPACE))
            (SETQ NUM (SUB1 NUM))
            (GO START))))

(ADDLAST
   (LAMBDA (X Y) (APPEND X (LIST Y))))
      
(WRITES
   (LAMBDA (X) (PROG (A)
      START (SETQ A (CAR X))
            (COND
               ((NULL X) (RETURN NIL))
               ((EQ A (QUOTE $EOR$)) (GO ON))
               ((ATOM A) (PRIN1 A))
               (T (PRIN1 (QUOTE ***))))
            (SETQ X (CDR X))
            (GO START)
      ON    (TERPRI)
            (RETURN NIL))))
))


METEOR((
(*   (ROSE) (FLOWER)  * (SIMPLE REPLACEMENT))
(*    ((*P THE WORKSPACE IS))             *  (DEBUG PRINTOUT))
(*   (IS A ROSE)     0    * (DELETION))
(*    (A FLOWER IS) (3 1 2)        * (REARRANGEMENT))
(*   ((*P WS2))      *)
(*   ( FLOWER) ( 1 OF RED)   * (INSERTION) )
(*    (A FLOWER) (THE 2)    * (REPLACEMENT IN CONTEXT))
(*    ((*P WS3))      *)
(*    (FLOWER)             * (NO OPERATION))
(*      (RED) (1 1)      * (DUPLICATION))
(*    ((*P WS4))      *)
(*    (OF ($.1))   (1)  *(SINGLE UNKNOWN CONSTITUENT))
(*     (($.1))   (QUESTION 1)     * (FIRST CONSTITUENT))
(*        ( (*P WS5))   *)
(*    ( ($.2) FLOWER ($.3))   (3 2 1) * (N CONSECTUTIVE CONSTITUENTS))
(*   ((*P WS6))     *)
(*    (FLOWER $ ROSE)  (1 3)  * (UNKNOWN NUM OF CONSTITUENTS))
(*   ( (*P WS7))    *)
(*       ($)  (START C A B D) * (REPLACEING ENTIRE WORKSPACE))
(*    (START ($.1)  $ D)   (1 3 2 4)  *)
(*     ((*P WS8)) *)
(*   ($)     END)
)(A ROSE IS A ROSE IS A ROSE))

METEOR((
(CHANGE   ($ ROSE) (FLOWER) (/ (*Q SHELF1 1 PRETTY)) CHANGE)
(*   ($)  ((*A SHELF1) 1)  (/(*D PNTRET RULE3)) *)
(PRNTWS * ((*P THE WORKSPACE IS)) PNTRET)
(RULE2 ($)         END)
(RULE3  (($.1)  ($.1)) 0 (/(*S ODD 1)(*Q EVEN 2) (*D PNTRET RULE3))
      PRNTWS  (THIS IS A CONTINUATION OF THE PREVIOUS CARD))
(*    ($)   ((*A ODD) (*N EVEN)) (/ (*Q ODD (*N EVEN) ONLY)
      (*P ODD EVEN)   (*D PNTRET RULE2))     PRNTWS)
)(A ROSE IS A ROSE IS A ROSE))

METEOR((
(DEAL ($1 $1) ((FN ADD1 1)) (/(*S * 1 2)) *)
(* * ($2)    PRINT)
(* (5)  ((QUOTE 1))  DEAL)
(*  ($)          DEAL)
(PRINT ($)  (/(*P /))    END)
)(1 H1 H2 H3 H4 C1 C2 C3 C4 D1 D2 D3 D4 S1 S2 S3 S4))

METEOR
(((* DICT (BOY ((BOY / NOUN HE)))
          (GIRL ((GIRL / NOUN SHE))))
(LOOKUP ((WORD ($.1))) 0 (/ (*Q SENT (FN GETDCT WORD DICT))
   (*P SENT)) LOOKUP)
   (* ($) ((*A SENT)) END))
(THE BOY AND THE GIRL))

METEOR
(((* ((BOY / NOUN SING)) ((*/ AND 1 (DOG / NOUN MALE))
(*/ OR 1 (BOY / SMALL MALE)) (*/ SUBST 1 (MAN / MALE)))
END)) (THE (BOY / NOUN SING SMALL) AT HOME))
TRACE ((
METEOR METRIX METRIX2 COMITRULE TRANSFER DISPATCH GTPAIR
FSTATM SHELVE SETDIS GETDCT INDIRECT COMITR COMITRIN
GTNAME COPYTP EXPAND COMPRESS MTREAD ALL NEXT GTSHLF
SBMERGE COMITMATCH CMATCH NAMER SUBMCH DOLNM ADDLAST
WRITES EQ SETQ APPLY LIST ))

METEOR
(((* (($.1) IS ($.2) $ THERE) ((*K 1 2 3 4)) END))
(WHO IT IS AT MY DOOR IS THERE NOW))

SPECIAL ((MPAIRS PRS WORKSPACE DISPCH SHELF TRACK))
STOP)))   )))   )))   )))
       TEST    OBJECTS
EVAL (OBLIST NIL)
MAP ((list(OBLIST NIL)) (PRINTPROP))
       test    mathread

define ((
(mathread (lambda () (prog ()
        (startread)
        (clearbuff)
look    (cond ((eq curchar lpar) (go start) ))
        (advance)
        (go look)
start   (return (group (list (list (input) )) (input) (input) ))
            )))

(group (lambda (u h s) (prog (x y z)
(setq x (get h (quote prefix) ))
(setq y (get s (quote pr) ))
(setq z (get (caar u) (quote pl) ))
        (cond ((null x) (go ind))
               ((eq x (qoute yes)) (return
(group (cond ((eq h (quote plus)) u)
        (t (cons (list h) u) )) s (input) ) )))
        (print (list (quote inputerror1) h))
        (return (group (nconc u (list nil)) s (input) ))
ind     (cond ((not (null y)) (go ok)))
        (print (list (quote inputerror2) s))
        (return (group (nconc u (list nil)) h (input) ))
ok      (return (cond
((eq s (quote lpar)) (group (cons (list s) u) h (quote comma) ))
((greaterp y z) (group (cons (list s h) u) (input) (input) ))
((lessp y z) (group (cdr u) (nconc (car u) (list h)) s))
((zerop y) (cond ((null (cdr u)) h)
                ((null (cadr u)) (error h))
                (t (group (cdr u)
       (cond ((eq (car h) (quote comma)) (cdr h)) (t h)) (input) )) ))
(t (group (cons (nconc (car u) (list h)) (cdr u)) (input) (input) ))
            )) )))

(input (lambda ( ) (prog (x)
aa       (cond ((liter curchar) (go let))
               ((digit curchar) (go dig)))
         (setq x (get curchar (quote switch) ))
         (cond ((eq x (quote blank)) (go ig))
               ((eq x (quote star)) (go castor))
               ((eq x (quote difference)) (go sub))
               ((null x) (go err)))
         (advance)
         (return x)
let      (pack curchar)
         (cond ( (or (liter (advance)) (digit curchar)) (go let)))
         (return (intern (mknam)))
dig      (pack curchar)
         (cond ((or (digit (advance))
                    (eq curchar period)
                    (eq curchar (quote e))) (go dig)))
         (return (numob))
ig       (advance) 
         (go aa)
castor   (cond ((eq (advance) star) (go pollux) ))
         (return (quote times) )
pollux   (advance)
         (return (quote expt) )
sub      (csetq curchar (quote minus) )
         (return (qoute plus) )
err      (error1)
         (go ig)
             )) )))
deflist ( (($$$+$ plus) ($$$-$ difference) (minus minus)
          (* star) (/ quotient) (= equal) ($$$,$ comma)
          ($$$.$ dot) ($$$($ lpar) ($$$)$ rpar)
          ($EOR$ blank) ($$$ $ blank)) switch)

deflist ( ((plus 30) (difference 50) (minus 50) (times 60)
          (quotient 70) (expr 90) (equal 20) (comma 10)
          (dot 110) (lpar 0) (rpar 0) ) pl)

deflist ( ((plus 30) (difference 40) (minus 40) (times 60)
          (quotient 80) (expt 100) (equal 20) (comma 10)
          (dot 120) (lpar 0) (rpar 0) ) pr)

deflist ( ((plus yes) (difference no) (minus yes) (times no)
           (quotient no) (expt no) (equal no) (comma no)
           (dot no) (lpar ya) (rpar no)) prefix)
mathread ( )
mathread ( )
mathread ( )
mathread ( )
mathread ( )
mathread ( )
opdefine1(tlq 40q8)
opdefine1(pxa 754q8)
opdefine1(Tra 20q8)
opdefine1(cla 500q8)
opdefine1(axt 774q8)

STOP)))   )))   )))   )))
(4.2)
(a + 4e2 + 4.2e3)
(a+f(.23 + 23.))
(a + * (b+c) + f(.23
                * (y + 5.6.7)))
(a + b c (x,,y,(z + 1.2e6e7))
(3.3.3e3e3 **** F)
       FIN      END OF LISP RUN       M948-1207 LEVIN          
